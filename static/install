#!/usr/bin/env bash
###############################################################################
#                    Actvt Remote Server Installation Script                  #
###############################################################################
#
# Description: Automated installation script for Actvt remote server monitoring
# Usage: curl https://actvt.io/install -fsS | bash
# Documentation: https://actvt.io/docs/remote-server/overview
#
# Version: 1.0.0
# Last Updated: 2025-10-08
#
###############################################################################

set -euo pipefail

# Script version
readonly SCRIPT_VERSION="1.0.0"

# Installation directories
readonly ACTVT_STATE_DIR="/var/lib/actvt"
readonly ACTVT_LOG_FILE="/var/log/actvt-install.log"
readonly ACTVT_BACKUP_DIR="${ACTVT_STATE_DIR}/backups"
readonly VECTOR_CONFIG_DIR="/etc/vector"
readonly VECTOR_CERTS_DIR="${VECTOR_CONFIG_DIR}/certs"

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color
readonly BOLD='\033[1m'

# Progress tracking
CURRENT_STEP=0
TOTAL_STEPS=7

###############################################################################
#                           Logging Functions                                 #
###############################################################################

log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Log to file
    echo "[${timestamp}] [${level}] ${message}" >> "${ACTVT_LOG_FILE}" 2>/dev/null || true

    # Log to console with colors
    case "${level}" in
        INFO)
            echo -e "${BLUE}ℹ${NC} ${message}"
            ;;
        SUCCESS)
            echo -e "${GREEN}✓${NC} ${message}"
            ;;
        WARNING)
            echo -e "${YELLOW}⚠${NC} ${message}"
            ;;
        ERROR)
            echo -e "${RED}✗${NC} ${message}"
            ;;
        STEP)
            CURRENT_STEP=$((CURRENT_STEP + 1))
            echo -e "\n${CYAN}${BOLD}[${CURRENT_STEP}/${TOTAL_STEPS}]${NC} ${BOLD}${message}${NC}"
            ;;
    esac
}

progress() {
    echo -e "${MAGENTA}  →${NC} $*"
}

###############################################################################
#                           Error Handling                                    #
###############################################################################

cleanup() {
    local exit_code=$?
    if [ ${exit_code} -ne 0 ]; then
        log ERROR "Installation failed with exit code ${exit_code}"
        log ERROR "Check the log file at ${ACTVT_LOG_FILE} for details"
        log INFO "You can try running the script again or follow the manual installation guide"
        log INFO "Documentation: https://actvt.io/docs/remote-server/overview"
    fi
}

trap cleanup EXIT

error_exit() {
    log ERROR "$1"
    exit 1
}

###############################################################################
#                        Interactive Mode Detection                           #
###############################################################################

is_interactive() {
    # Check if explicitly set to non-interactive
    if [ "${ACTVT_NON_INTERACTIVE:-}" = "yes" ]; then
        return 1
    fi
    # Check if stdin is a terminal
    [ -t 0 ]
}

###############################################################################
#                           OS Detection                                      #
###############################################################################

detect_os() {
    log STEP "Detecting Operating System"

    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS_NAME="${ID}"
        OS_VERSION="${VERSION_ID}"
        OS_PRETTY_NAME="${PRETTY_NAME}"
    elif [ -f /etc/lsb-release ]; then
        . /etc/lsb-release
        OS_NAME="${DISTRIB_ID,,}"
        OS_VERSION="${DISTRIB_RELEASE}"
        OS_PRETTY_NAME="${DISTRIB_DESCRIPTION}"
    elif [ -f /etc/redhat-release ]; then
        OS_NAME="rhel"
        OS_VERSION=$(cat /etc/redhat-release | grep -oP '\d+\.\d+' | head -1)
        OS_PRETTY_NAME=$(cat /etc/redhat-release)
    else
        error_exit "Unsupported operating system. Supported: Ubuntu, Debian, CentOS, RHEL, Amazon Linux"
    fi

    progress "Detected: ${OS_PRETTY_NAME}"

    # Determine package manager
    case "${OS_NAME}" in
        ubuntu|debian)
            PKG_MANAGER="apt-get"
            PKG_UPDATE="apt-get update"
            PKG_INSTALL="apt-get install -y"
            ;;
        centos|rhel)
            if command -v dnf &> /dev/null; then
                PKG_MANAGER="dnf"
                PKG_UPDATE="dnf check-update || true"
                PKG_INSTALL="dnf install -y"
            else
                PKG_MANAGER="yum"
                PKG_UPDATE="yum check-update || true"
                PKG_INSTALL="yum install -y"
            fi
            ;;
        amzn|amazonlinux)
            PKG_MANAGER="yum"
            PKG_UPDATE="yum check-update || true"
            PKG_INSTALL="yum install -y"
            ;;
        *)
            error_exit "Unsupported distribution: ${OS_NAME}"
            ;;
    esac

    progress "Package manager: ${PKG_MANAGER}"
    log SUCCESS "OS detection complete"
}

###############################################################################
#                        System Requirements Check                            #
###############################################################################

check_requirements() {
    log STEP "Checking System Requirements"

    # Check if running as root or with sudo
    if [ "$EUID" -ne 0 ]; then
        error_exit "This script must be run as root or with sudo"
    fi

    progress "Root access: OK"

    # Check available disk space (need at least 100MB)
    local available_space=$(df /tmp | tail -1 | awk '{print $4}')
    if [ "${available_space}" -lt 102400 ]; then
        error_exit "Insufficient disk space. Need at least 100MB free"
    fi
    progress "Disk space: OK ($(numfmt --to=iec-i --suffix=B $((available_space * 1024))))"

    # Check available memory (need at least 512MB)
    local available_mem=$(free -m | awk '/^Mem:/{print $2}')
    if [ "${available_mem}" -lt 512 ]; then
        log WARNING "Low memory detected (${available_mem}MB). Recommended: 1GB+"
    else
        progress "Memory: OK (${available_mem}MB)"
    fi

    # Check internet connectivity
    if ! ping -c 1 -W 2 8.8.8.8 &> /dev/null; then
        error_exit "No internet connectivity detected"
    fi
    progress "Internet connectivity: OK"

    # Check if required commands are available
    for cmd in curl tar; do
        if ! command -v ${cmd} &> /dev/null; then
            progress "Installing ${cmd}..."
            ${PKG_INSTALL} ${cmd} >> "${ACTVT_LOG_FILE}" 2>&1
        fi
    done

    log SUCCESS "All system requirements met"
}

###############################################################################
#                           Vector Installation                               #
###############################################################################

install_vector() {
    log STEP "Installing Vector"

    # Check if Vector is already installed
    if command -v vector &> /dev/null; then
        local installed_version=$(vector --version | grep -oP 'vector \K[0-9.]+' || echo "unknown")
        log INFO "Vector is already installed (version ${installed_version})"

        # Check environment variable first
        if [ -n "${ACTVT_REINSTALL_VECTOR:-}" ]; then
            if [[ "${ACTVT_REINSTALL_VECTOR}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                progress "Reinstalling Vector (ACTVT_REINSTALL_VECTOR=yes)"
            else
                log INFO "Skipping Vector installation (ACTVT_REINSTALL_VECTOR=${ACTVT_REINSTALL_VECTOR})"
                return 0
            fi
        # In non-interactive mode, skip by default
        elif ! is_interactive; then
            log INFO "Skipping Vector installation (non-interactive mode)"
            return 0
        # Interactive mode - prompt user
        else
            read -p "Do you want to reinstall/update Vector? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log INFO "Skipping Vector installation"
                return 0
            fi
        fi
    fi

    progress "Adding Vector repository..."

    case "${PKG_MANAGER}" in
        apt-get)
            # Add Vector repository for Debian/Ubuntu
            bash -c "$(curl -L https://setup.vector.dev)" >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to add Vector repository"

            progress "Updating package list..."
            ${PKG_UPDATE} >> "${ACTVT_LOG_FILE}" 2>&1

            progress "Installing Vector package..."
            ${PKG_INSTALL} vector >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to install Vector"
            ;;

        yum|dnf)
            # Add Vector repository for RHEL/CentOS/Amazon Linux
            bash -c "$(curl -L https://setup.vector.dev)" >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to add Vector repository"

            progress "Installing Vector package..."
            ${PKG_INSTALL} vector >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to install Vector"
            ;;
    esac

    # Verify installation
    if ! command -v vector &> /dev/null; then
        error_exit "Vector installation failed"
    fi

    local vector_version=$(vector --version | grep -oP 'vector \K[0-9.]+' || echo "unknown")
    progress "Vector ${vector_version} installed successfully"

    # Verify systemd service
    if systemctl list-unit-files | grep -q vector.service; then
        progress "Vector systemd service: OK"
    else
        log WARNING "Vector systemd service not found"
    fi

    # Verify vector user was created
    if id vector &> /dev/null; then
        progress "Vector user created: OK"
    else
        log WARNING "Vector user not found, creating manually..."
        useradd -r -s /bin/false vector || true
    fi

    log SUCCESS "Vector installation complete"
}

###############################################################################
#                          Vector Configuration                               #
###############################################################################

detect_gpu() {
    # Check if nvidia-smi is available and working
    if command -v nvidia-smi &> /dev/null; then
        if nvidia-smi &> /dev/null; then
            local gpu_name=$(nvidia-smi --query-gpu=name --format=csv,noheader | head -1)
            log INFO "NVIDIA GPU detected: ${gpu_name}"
            return 0
        fi
    fi
    return 1
}

configure_vector() {
    log STEP "Configuring Vector"

    # Detect GPU
    local gpu_enabled="false"
    if detect_gpu; then
        # Check environment variable first
        if [ -n "${ACTVT_ENABLE_GPU:-}" ]; then
            if [[ "${ACTVT_ENABLE_GPU}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                gpu_enabled="true"
                progress "GPU monitoring enabled (ACTVT_ENABLE_GPU=yes)"
            else
                progress "GPU monitoring disabled (ACTVT_ENABLE_GPU=${ACTVT_ENABLE_GPU})"
            fi
        # In non-interactive mode, enable by default if GPU detected
        elif ! is_interactive; then
            gpu_enabled="true"
            progress "GPU monitoring enabled (non-interactive mode, GPU detected)"
        # Interactive mode - prompt user
        else
            read -p "Enable GPU monitoring? [Y/n] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                gpu_enabled="true"
                progress "GPU monitoring will be enabled"
            fi
        fi
    fi

    # Backup existing configuration if it exists
    if [ -f "${VECTOR_CONFIG_DIR}/vector.toml" ]; then
        mkdir -p "${ACTVT_BACKUP_DIR}"
        cp "${VECTOR_CONFIG_DIR}/vector.toml" \
           "${ACTVT_BACKUP_DIR}/vector.toml.backup.$(date +%Y%m%d_%H%M%S)"
        progress "Existing configuration backed up"
    fi

    # Create Vector configuration directory
    mkdir -p "${VECTOR_CONFIG_DIR}"

    progress "Creating Vector configuration..."

    # Generate vector.toml
    cat > "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
###############################################################################
#                    vector.toml Production Configuration                     #
###############################################################################

################################ 1. SOURCES ###################################

[sources.system_metrics]
type                 = "host_metrics"
collectors           = ["cpu", "memory"]
scrape_interval_secs = 1

EOF

    # Add GPU configuration if enabled
    if [ "${gpu_enabled}" = "true" ]; then
        cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
# GPU metrics (requires nvidia-smi)
[sources.gpu_metrics]
type    = "exec"
command = [
  "nvidia-smi",
  "--query-gpu=utilization.gpu",
  "--format=csv,noheader,nounits"
]
mode = "scheduled"

[sources.gpu_metrics.scheduled]
exec_interval_secs = 1

EOF
    fi

    # Add transforms and sinks
    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
################################# 2. NORMALISE ################################

[transforms.metrics_to_logs]
type   = "metric_to_log"
inputs = ["system_metrics"]

EOF

    if [ "${gpu_enabled}" = "true" ]; then
        cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
[transforms.format_gpu]
type   = "remap"
inputs = ["gpu_metrics"]
source = '''
.metric_type = "gpu"
.value       = to_float!(.message)
.host        = get_env_var("HOSTNAME") ?? "unknown-host"
.timestamp   = format_timestamp!(now(), format: "%+")
'''

EOF
    fi

    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
[transforms.rewrite_mem_names]
type   = "remap"
inputs = ["metrics_to_logs"]
source = '''
if starts_with!(.name, "memory_") {
  .name = "host_" + to_string!(.name)
}
'''

################################ 3. FILTER & TAG ##############################

[transforms.format_metrics]
type   = "remap"
inputs = ["rewrite_mem_names"]
source = '''
# ----- derive a reliable host field -----
hostname = if !is_null(.host) {
             .host
           } else if !is_null(.tags.host) {
             .tags.host
           } else {
             get_env_var("HOSTNAME") ?? "unknown-host"
           }

# -------- filter + rename the metrics we care about --------
if .name == "host_memory_used_bytes" {
  .metric_type = "memory_used"
  .value       = .gauge.value
  .host        = hostname

} else if .name == "host_memory_total_bytes" {
  .metric_type = "memory_total"
  .value       = .gauge.value
  .host        = hostname

} else if (.name == "host_cpu_seconds_total" || .name == "cpu_seconds_total") && .tags.mode == "idle" {
  .metric_type = "cpu_idle"
  .value       = .counter.value
  .cpu         = .tags.cpu
  .host        = hostname

} else if (.name == "host_cpu_seconds_total" || .name == "cpu_seconds_total") {
  .metric_type = "cpu_total"
  .value       = .counter.value
  .cpu         = .tags.cpu
  .host        = hostname

} else {
  abort   # drop everything else
}

.timestamp = format_timestamp!(now(), format: "%+")
'''

################################ 4. PRODUCTION SINK ###########################

[sinks.websocket_out]
type    = "websocket_server"
EOF

    # Set inputs based on GPU configuration
    if [ "${gpu_enabled}" = "true" ]; then
        echo 'inputs  = ["format_metrics", "format_gpu"]' >> "${VECTOR_CONFIG_DIR}/vector.toml"
    else
        echo 'inputs  = ["format_metrics"]' >> "${VECTOR_CONFIG_DIR}/vector.toml"
    fi

    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
address = "0.0.0.0:4096"

encoding.codec            = "json"
encoding.timestamp_format = "rfc3339"

[sinks.websocket_out.tls]
enabled  = true
crt_file = "/etc/vector/certs/server.crt"
key_file = "/etc/vector/certs/server.key"

################################ 5. API #######################################

[api]
enabled = true
EOF

    # Set proper permissions
    chown -R vector:vector "${VECTOR_CONFIG_DIR}" || true
    chmod 644 "${VECTOR_CONFIG_DIR}/vector.toml"

    # Validate configuration (will fail if certs don't exist yet, but that's expected)
    progress "Validating configuration..."
    if vector validate "${VECTOR_CONFIG_DIR}/vector.toml" >> "${ACTVT_LOG_FILE}" 2>&1; then
        log SUCCESS "Vector configuration valid"
    else
        # Expected to fail without TLS certs
        log INFO "Configuration created (TLS certificates required before starting)"
    fi

    log SUCCESS "Vector configuration complete"
}

###############################################################################
#                           TLS Certificate Setup                             #
###############################################################################

setup_tls() {
    log STEP "Setting up TLS Certificates"

    # Prompt for domain name
    local domain=""
    if [ -n "${ACTVT_DOMAIN:-}" ]; then
        domain="${ACTVT_DOMAIN}"
        log INFO "Using domain from environment: ${domain}"
    else
        echo
        echo -e "${BOLD}Enter your domain name (e.g., monitor.yourdomain.com):${NC}"
        read -p "> " domain

        if [ -z "${domain}" ]; then
            error_exit "Domain name is required for TLS certificates"
        fi
    fi

    progress "Domain: ${domain}"

    # Verify DNS resolution
    progress "Verifying DNS resolution..."
    if ! host "${domain}" &> /dev/null; then
        log WARNING "Domain ${domain} does not resolve. Please ensure DNS is configured correctly."
        log WARNING "Certificate acquisition may fail if DNS is not properly configured."

        # Check environment variable first
        if [ -n "${ACTVT_CONTINUE_WITHOUT_DNS:-}" ]; then
            if [[ "${ACTVT_CONTINUE_WITHOUT_DNS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                log WARNING "Continuing without DNS resolution (ACTVT_CONTINUE_WITHOUT_DNS=yes)"
            else
                error_exit "DNS not configured (ACTVT_CONTINUE_WITHOUT_DNS=${ACTVT_CONTINUE_WITHOUT_DNS})"
            fi
        # In non-interactive mode, fail by default
        elif ! is_interactive; then
            error_exit "DNS not configured (non-interactive mode). Set ACTVT_CONTINUE_WITHOUT_DNS=yes to override"
        # Interactive mode - prompt user
        else
            read -p "Continue anyway? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                error_exit "Please configure DNS and try again"
            fi
        fi
    else
        progress "DNS resolution: OK"
    fi

    # Install Certbot
    progress "Installing Certbot..."
    case "${PKG_MANAGER}" in
        apt-get)
            ${PKG_INSTALL} certbot >> "${ACTVT_LOG_FILE}" 2>&1
            ;;
        yum|dnf)
            # Enable EPEL repository for CentOS/RHEL
            if [ "${OS_NAME}" = "centos" ] || [ "${OS_NAME}" = "rhel" ]; then
                ${PKG_INSTALL} epel-release >> "${ACTVT_LOG_FILE}" 2>&1 || true
            fi
            ${PKG_INSTALL} certbot >> "${ACTVT_LOG_FILE}" 2>&1
            ;;
    esac

    if ! command -v certbot &> /dev/null; then
        error_exit "Failed to install Certbot"
    fi
    progress "Certbot installed successfully"

    # Prompt for email
    local email=""
    if [ -n "${ACTVT_EMAIL:-}" ]; then
        email="${ACTVT_EMAIL}"
    else
        echo
        echo -e "${BOLD}Enter your email for Let's Encrypt notifications (optional):${NC}"
        read -p "> " email
    fi

    # Check if certificate already exists
    if [ -d "/etc/letsencrypt/live/${domain}" ]; then
        log INFO "Certificate for ${domain} already exists"

        # Check environment variable first
        local reuse_cert="yes"
        if [ -n "${ACTVT_REUSE_CERT:-}" ]; then
            reuse_cert="${ACTVT_REUSE_CERT}"
        # In non-interactive mode, reuse by default
        elif ! is_interactive; then
            reuse_cert="yes"
        # Interactive mode - prompt user
        else
            read -p "Reuse existing certificate? [Y/n] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                reuse_cert="no"
            fi
        fi

        if [[ "${reuse_cert}" =~ ^[Yy]([Ee][Ss])?$ ]] || [[ "${reuse_cert}" == "yes" ]]; then
            progress "Using existing certificate"
        else
            progress "Obtaining new certificate..."
            certbot certonly --standalone -d "${domain}" \
                ${email:+--email "${email}"} \
                --agree-tos --non-interactive --force-renewal \
                >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to obtain Let's Encrypt certificate"
        fi
    else
        progress "Obtaining Let's Encrypt certificate..."
        log INFO "This requires port 80 to be temporarily accessible"

        if [ -n "${email}" ]; then
            certbot certonly --standalone -d "${domain}" \
                --email "${email}" --agree-tos --non-interactive \
                >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to obtain Let's Encrypt certificate. Ensure port 80 is accessible."
        else
            certbot certonly --standalone -d "${domain}" \
                --register-unsafely-without-email --agree-tos --non-interactive \
                >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to obtain Let's Encrypt certificate. Ensure port 80 is accessible."
        fi
    fi

    # Create Vector certs directory
    mkdir -p "${VECTOR_CERTS_DIR}"

    # Copy certificates to Vector directory
    progress "Installing certificates for Vector..."
    cp "/etc/letsencrypt/live/${domain}/fullchain.pem" "${VECTOR_CERTS_DIR}/server.crt" || \
        error_exit "Failed to copy certificate"
    cp "/etc/letsencrypt/live/${domain}/privkey.pem" "${VECTOR_CERTS_DIR}/server.key" || \
        error_exit "Failed to copy private key"

    # Set proper permissions
    chown -R vector:vector "${VECTOR_CERTS_DIR}"
    chmod 600 "${VECTOR_CERTS_DIR}/server.key"
    chmod 644 "${VECTOR_CERTS_DIR}/server.crt"

    progress "Certificates installed successfully"

    # Set up auto-renewal
    progress "Setting up automatic certificate renewal..."

    # Create renewal hook script
    local renewal_hook="/etc/letsencrypt/renewal-hooks/deploy/actvt-vector.sh"
    mkdir -p "$(dirname ${renewal_hook})"

    cat > "${renewal_hook}" << 'RENEWAL_EOF'
#!/bin/bash
# Copy renewed certificates to Vector directory
cp "/etc/letsencrypt/live/${RENEWED_LINEAGE##*/}/fullchain.pem" /etc/vector/certs/server.crt
cp "/etc/letsencrypt/live/${RENEWED_LINEAGE##*/}/privkey.pem" /etc/vector/certs/server.key
chown -R vector:vector /etc/vector/certs
chmod 600 /etc/vector/certs/server.key
chmod 644 /etc/vector/certs/server.crt
systemctl reload vector || systemctl restart vector
RENEWAL_EOF

    chmod +x "${renewal_hook}"

    # Test renewal (dry-run)
    if certbot renew --dry-run >> "${ACTVT_LOG_FILE}" 2>&1; then
        progress "Auto-renewal configured successfully"
    else
        log WARNING "Auto-renewal test failed, but certificates are installed"
    fi

    # Store domain for later use
    echo "${domain}" > "${ACTVT_STATE_DIR}/domain"

    log SUCCESS "TLS certificates configured successfully"
}

###############################################################################
#                          Firewall Configuration                             #
###############################################################################

configure_firewall() {
    log STEP "Configuring Firewall"

    # Detect firewall
    local firewall_type=""
    if command -v ufw &> /dev/null; then
        firewall_type="ufw"
    elif command -v firewall-cmd &> /dev/null; then
        firewall_type="firewalld"
    elif command -v iptables &> /dev/null; then
        firewall_type="iptables"
    else
        log WARNING "No firewall detected. Please configure firewall manually."
        log INFO "Required ports: 80 (HTTP), 443 (HTTPS), 4096 (WebSocket)"
        return 0
    fi

    progress "Detected firewall: ${firewall_type}"

    case "${firewall_type}" in
        ufw)
            progress "Configuring UFW..."

            # Enable UFW if not already enabled
            if ! ufw status | grep -q "Status: active"; then
                log WARNING "UFW is not active. Enabling UFW..."
                # Allow SSH first to prevent lockout
                ufw allow 22/tcp >> "${ACTVT_LOG_FILE}" 2>&1
                yes | ufw enable >> "${ACTVT_LOG_FILE}" 2>&1
            fi

            # Allow required ports
            ufw allow 80/tcp >> "${ACTVT_LOG_FILE}" 2>&1
            ufw allow 443/tcp >> "${ACTVT_LOG_FILE}" 2>&1
            ufw allow 4096/tcp >> "${ACTVT_LOG_FILE}" 2>&1

            progress "Firewall rules added"
            ;;

        firewalld)
            progress "Configuring firewalld..."

            # Start firewalld if not running
            if ! systemctl is-active --quiet firewalld; then
                systemctl start firewalld
            fi

            # Allow required ports
            firewall-cmd --permanent --add-port=80/tcp >> "${ACTVT_LOG_FILE}" 2>&1
            firewall-cmd --permanent --add-port=443/tcp >> "${ACTVT_LOG_FILE}" 2>&1
            firewall-cmd --permanent --add-port=4096/tcp >> "${ACTVT_LOG_FILE}" 2>&1
            firewall-cmd --reload >> "${ACTVT_LOG_FILE}" 2>&1

            progress "Firewall rules added"
            ;;

        iptables)
            progress "Configuring iptables..."

            # Add rules if they don't exist
            iptables -C INPUT -p tcp --dport 80 -j ACCEPT 2>/dev/null || \
                iptables -I INPUT -p tcp --dport 80 -j ACCEPT
            iptables -C INPUT -p tcp --dport 443 -j ACCEPT 2>/dev/null || \
                iptables -I INPUT -p tcp --dport 443 -j ACCEPT
            iptables -C INPUT -p tcp --dport 4096 -j ACCEPT 2>/dev/null || \
                iptables -I INPUT -p tcp --dport 4096 -j ACCEPT

            # Try to save rules
            if command -v iptables-save &> /dev/null; then
                iptables-save > /etc/iptables/rules.v4 2>/dev/null || \
                    log WARNING "Could not persist iptables rules. They may not survive reboot."
            fi

            progress "Firewall rules added"
            ;;
    esac

    log SUCCESS "Firewall configuration complete"
}

###############################################################################
#                          Service Management                                 #
###############################################################################

start_vector_service() {
    log STEP "Starting Vector Service"

    # Enable systemd service
    progress "Enabling Vector service..."
    systemctl enable vector >> "${ACTVT_LOG_FILE}" 2>&1

    # Start service
    progress "Starting Vector..."
    if systemctl start vector >> "${ACTVT_LOG_FILE}" 2>&1; then
        progress "Vector service started successfully"
    else
        log ERROR "Failed to start Vector service"
        log INFO "Checking service status..."
        systemctl status vector --no-pager >> "${ACTVT_LOG_FILE}" 2>&1 || true
        error_exit "Vector service failed to start. Check logs: journalctl -u vector -n 50"
    fi

    # Wait a moment for service to initialize
    sleep 2

    # Verify service is running
    if systemctl is-active --quiet vector; then
        progress "Vector service is active"
    else
        error_exit "Vector service is not running"
    fi

    log SUCCESS "Vector service started and enabled"
}

###############################################################################
#                          Validation & Testing                               #
###############################################################################

validate_installation() {
    log STEP "Validating Installation"

    # Check Vector is running
    progress "Checking Vector service..."
    if systemctl is-active --quiet vector; then
        progress "Vector service: Running ✓"
    else
        log ERROR "Vector service is not running"
        return 1
    fi

    # Check port 4096 is listening
    progress "Checking WebSocket port..."
    if netstat -tuln 2>/dev/null | grep -q ":4096 " || \
       ss -tuln 2>/dev/null | grep -q ":4096 "; then
        progress "Port 4096: Listening ✓"
    else
        log WARNING "Port 4096 is not listening yet (may take a moment)"
    fi

    # Check TLS certificates exist and are valid
    progress "Checking TLS certificates..."
    if [ -f "${VECTOR_CERTS_DIR}/server.crt" ] && [ -f "${VECTOR_CERTS_DIR}/server.key" ]; then
        local cert_expiry=$(openssl x509 -in "${VECTOR_CERTS_DIR}/server.crt" -noout -enddate 2>/dev/null | cut -d= -f2)
        progress "TLS certificates: Valid until ${cert_expiry} ✓"
    else
        log ERROR "TLS certificates not found"
        return 1
    fi

    # Get domain from state file
    local domain=""
    if [ -f "${ACTVT_STATE_DIR}/domain" ]; then
        domain=$(cat "${ACTVT_STATE_DIR}/domain")
    fi

    log SUCCESS "Installation validation complete"

    # Display connection information
    echo
    echo -e "${GREEN}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}${BOLD}  Installation Complete!${NC}"
    echo -e "${GREEN}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
    echo -e "${BOLD}WebSocket URL:${NC}"
    if [ -n "${domain}" ]; then
        echo -e "  ${CYAN}wss://${domain}:4096${NC}"
    else
        echo -e "  ${CYAN}wss://YOUR_DOMAIN:4096${NC}"
    fi
    echo
    echo -e "${BOLD}Next Steps:${NC}"
    echo -e "  1. Open Actvt on your Mac"
    echo -e "  2. Go to Settings → Remote Servers"
    echo -e "  3. Add a new server with the WebSocket URL above"
    echo -e "  4. Start monitoring your remote server!"
    echo
    echo -e "${BOLD}Service Management:${NC}"
    echo -e "  • Check status:  ${CYAN}sudo systemctl status vector${NC}"
    echo -e "  • View logs:     ${CYAN}sudo journalctl -u vector -f${NC}"
    echo -e "  • Restart:       ${CYAN}sudo systemctl restart vector${NC}"
    echo
    echo -e "${BOLD}Documentation:${NC}"
    echo -e "  ${CYAN}https://actvt.io/docs/remote-server/overview${NC}"
    echo
    echo -e "${GREEN}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
}

###############################################################################
#                              Main Execution                                 #
###############################################################################

main() {
    # Clear screen and show banner
    clear
    echo -e "${CYAN}${BOLD}"
    echo "╔═══════════════════════════════════════════════════════════════╗"
    echo "║                                                               ║"
    echo "║           Actvt Remote Server Installation Script            ║"
    echo "║                      Version ${SCRIPT_VERSION}                        ║"
    echo "║                                                               ║"
    echo "╚═══════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    echo

    # Create state directory
    mkdir -p "${ACTVT_STATE_DIR}"
    mkdir -p "${ACTVT_BACKUP_DIR}"

    # Initialize log file
    touch "${ACTVT_LOG_FILE}" 2>/dev/null || ACTVT_LOG_FILE="/tmp/actvt-install.log"
    chmod 644 "${ACTVT_LOG_FILE}"

    log INFO "Starting Actvt installation (version ${SCRIPT_VERSION})"
    log INFO "Log file: ${ACTVT_LOG_FILE}"

    # Run installation steps
    detect_os
    check_requirements
    install_vector
    configure_vector
    setup_tls
    configure_firewall
    start_vector_service
    validate_installation

    # Save installation state
    echo "version=${SCRIPT_VERSION}" > "${ACTVT_STATE_DIR}/install.state"
    echo "installed_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "${ACTVT_STATE_DIR}/install.state"

    log INFO "Installation completed successfully"
}

# Run main function
main "$@"
