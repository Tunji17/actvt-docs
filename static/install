#!/usr/bin/env bash
###############################################################################
#                    Actvt Remote Server Installation Script                  #
###############################################################################
#
# Description: Automated installation script for Actvt remote server monitoring
#
# Required environment variables:
#   ACTVT_DOMAIN - Your server domain name (e.g., monitor.yourdomain.com)
#   ACTVT_EMAIL  - Email address for Let's Encrypt notifications
#
# Usage:
#   export ACTVT_DOMAIN=monitor.yourdomain.com
#   export ACTVT_EMAIL=admin@yourdomain.com
#   curl https://actvt.io/install -fsS | bash
#
# Documentation: https://actvt.io/docs/remote-server/overview
#
# Version: 1.0.0
# Last Updated: 2025-10-08
#
###############################################################################

set -euo pipefail

# Script version
readonly SCRIPT_VERSION="1.0.0"

# Installation directories
readonly ACTVT_STATE_DIR="/var/lib/actvt"
readonly ACTVT_LOG_FILE="/var/log/actvt-install.log"
readonly ACTVT_BACKUP_DIR="${ACTVT_STATE_DIR}/backups"
readonly VECTOR_CONFIG_DIR="/etc/vector"
readonly VECTOR_CERTS_DIR="${VECTOR_CONFIG_DIR}/certs"

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color
readonly BOLD='\033[1m'

# Progress tracking
CURRENT_STEP=0
TOTAL_STEPS=7

###############################################################################
#                           Logging Functions                                 #
###############################################################################

log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Log to file
    echo "[${timestamp}] [${level}] ${message}" >> "${ACTVT_LOG_FILE}" 2>/dev/null || true

    # Log to console with colors
    case "${level}" in
        INFO)
            echo -e "${BLUE}ℹ${NC} ${message}"
            ;;
        SUCCESS)
            echo -e "${GREEN}✓${NC} ${message}"
            ;;
        WARNING)
            echo -e "${YELLOW}⚠${NC} ${message}"
            ;;
        ERROR)
            echo -e "${RED}✗${NC} ${message}"
            ;;
        STEP)
            CURRENT_STEP=$((CURRENT_STEP + 1))
            echo -e "\n${CYAN}${BOLD}[${CURRENT_STEP}/${TOTAL_STEPS}]${NC} ${BOLD}${message}${NC}"
            ;;
    esac
}

progress() {
    echo -e "${CYAN}  →${NC} $*"
}

###############################################################################
#                           Error Handling                                    #
###############################################################################

cleanup() {
    local exit_code=$?
    if [ ${exit_code} -ne 0 ]; then
        log ERROR "Installation failed with exit code ${exit_code}"
        log ERROR "Check the log file at ${ACTVT_LOG_FILE} for details"
        log INFO "You can try running the script again or follow the manual installation guide"
        log INFO "Documentation: https://actvt.io/docs/remote-server/overview"
    fi
}

trap cleanup EXIT

error_exit() {
    log ERROR "$1"
    exit 1
}

###############################################################################
#                        Interactive Mode Detection                           #
###############################################################################

is_interactive() {
    # Check if explicitly set to non-interactive
    if [ "${ACTVT_NON_INTERACTIVE:-}" = "yes" ]; then
        return 1
    fi
    # Check if stdin is a terminal
    [ -t 0 ]
}

###############################################################################
#                           OS Detection                                      #
###############################################################################

detect_os() {
    log STEP "Detecting Operating System"

    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS_NAME="${ID}"
        OS_VERSION="${VERSION_ID}"
        OS_PRETTY_NAME="${PRETTY_NAME}"
    elif [ -f /etc/lsb-release ]; then
        . /etc/lsb-release
        OS_NAME="${DISTRIB_ID,,}"
        OS_VERSION="${DISTRIB_RELEASE}"
        OS_PRETTY_NAME="${DISTRIB_DESCRIPTION}"
    elif [ -f /etc/redhat-release ]; then
        OS_NAME="rhel"
        OS_VERSION=$(cat /etc/redhat-release | grep -oP '\d+\.\d+' | head -1)
        OS_PRETTY_NAME=$(cat /etc/redhat-release)
    else
        error_exit "Unsupported operating system. Supported: Ubuntu, Debian, CentOS, RHEL, Amazon Linux"
    fi

    progress "Detected: ${OS_PRETTY_NAME}"

    # Determine package manager
    case "${OS_NAME}" in
        ubuntu|debian)
            PKG_MANAGER="apt-get"
            PKG_UPDATE="apt-get update"
            PKG_INSTALL="apt-get install -y"
            ;;
        centos|rhel)
            if command -v dnf &> /dev/null; then
                PKG_MANAGER="dnf"
                PKG_UPDATE="dnf check-update || true"
                PKG_INSTALL="dnf install -y"
            else
                PKG_MANAGER="yum"
                PKG_UPDATE="yum check-update || true"
                PKG_INSTALL="yum install -y"
            fi
            ;;
        amzn|amazonlinux)
            PKG_MANAGER="yum"
            PKG_UPDATE="yum check-update || true"
            PKG_INSTALL="yum install -y"
            ;;
        *)
            error_exit "Unsupported distribution: ${OS_NAME}"
            ;;
    esac

    progress "Package manager: ${PKG_MANAGER}"
    log SUCCESS "OS detection complete"
}

###############################################################################
#                        System Requirements Check                            #
###############################################################################

check_requirements() {
    log STEP "Checking System Requirements"

    # Check if running as root or with sudo
    if [ "$EUID" -ne 0 ]; then
        error_exit "This script must be run as root or with sudo"
    fi

    # Check required environment variables
    if [ -z "${ACTVT_DOMAIN:-}" ]; then
        error_exit "ACTVT_DOMAIN environment variable is required. Example: export ACTVT_DOMAIN=monitor.yourdomain.com"
    fi

    if [ -z "${ACTVT_EMAIL:-}" ]; then
        error_exit "ACTVT_EMAIL environment variable is required. Example: export ACTVT_EMAIL=admin@yourdomain.com"
    fi

    # Validate domain format (RFC 1123 compliant)
    if ! [[ "${ACTVT_DOMAIN}" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
        error_exit "Invalid domain format. Must be a valid hostname (e.g., monitor.example.com)"
    fi

    # Validate email format (RFC 5322 basic)
    if ! [[ "${ACTVT_EMAIL}" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        error_exit "Invalid email format. Must be a valid email address"
    fi

    # Redact sensitive information in logs (show partial for verification)
    progress "Domain: ${ACTVT_DOMAIN:0:3}***${ACTVT_DOMAIN: -4}"
    progress "Email: ${ACTVT_EMAIL%%@*}@***"

    # DNS Configuration Warning
    log WARNING "IMPORTANT: DNS Configuration Required"
    log WARNING "Your domain must have an A or CNAME record pointing to this server"
    log WARNING "pointing to this server's IP address for Let's Encrypt to work."
    log WARNING "Without proper DNS configuration, certificate acquisition will fail."

    # Check available disk space (need at least 100MB)
    local available_space=$(df /tmp | tail -1 | awk '{print $4}')
    if [ "${available_space}" -lt 102400 ]; then
        error_exit "Insufficient disk space. Need at least 100MB free"
    fi
    progress "Disk space: OK ($(numfmt --to=iec-i --suffix=B $((available_space * 1024))))"

    # Check available memory (need at least 512MB)
    local available_mem=$(free -m | awk '/^Mem:/{print $2}')
    if [ "${available_mem}" -lt 512 ]; then
        log WARNING "Low memory detected (${available_mem}MB). Recommended: 1GB+"
    else
        progress "Memory: OK (${available_mem}MB)"
    fi

    # Check internet connectivity
    if ! ping -c 1 -W 2 8.8.8.8 &> /dev/null; then
        error_exit "No internet connectivity detected"
    fi

    # Check if required commands are available
    for cmd in curl tar; do
        if ! command -v ${cmd} &> /dev/null; then
            progress "Installing ${cmd}..."
            ${PKG_INSTALL} ${cmd} >> "${ACTVT_LOG_FILE}" 2>&1
        fi
    done

    log SUCCESS "All system requirements met"
}

###############################################################################
#                           Vector Installation                               #
###############################################################################

install_vector() {
    log STEP "Installing Vector"

    # Check if Vector is already installed
    if command -v vector &> /dev/null; then
        local installed_version=$(vector --version | grep -oP 'vector \K[0-9.]+' || echo "unknown")
        log INFO "Vector is already installed (version ${installed_version})"

        # Check environment variable first
        if [ -n "${ACTVT_REINSTALL_VECTOR:-}" ]; then
            if [[ "${ACTVT_REINSTALL_VECTOR}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                progress "Reinstalling Vector (ACTVT_REINSTALL_VECTOR=yes)"
            else
                log INFO "Skipping Vector installation (ACTVT_REINSTALL_VECTOR=${ACTVT_REINSTALL_VECTOR})"
                return 0
            fi
        # In non-interactive mode, skip by default
        elif ! is_interactive; then
            log INFO "Skipping Vector installation (non-interactive mode)"
            return 0
        # Interactive mode - prompt user
        else
            read -p "Do you want to reinstall/update Vector? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log INFO "Skipping Vector installation"
                return 0
            fi
        fi
    fi

    # Vector version to install
    readonly VECTOR_VERSION="0.50.0-1"

    progress "Adding Vector repository..."

    case "${PKG_MANAGER}" in
        apt-get)
            # Install required packages for repository management
            progress "Installing repository dependencies..."
            ${PKG_INSTALL} apt-transport-https gnupg ca-certificates curl >> "${ACTVT_LOG_FILE}" 2>&1

            # Add Datadog GPG keys for package verification
            progress "Adding Vector GPG keys..."
            curl -fsSL https://keys.datadoghq.com/DATADOG_APT_KEY_CURRENT.public 2>> "${ACTVT_LOG_FILE}" | \
                gpg --dearmor -o /usr/share/keyrings/datadog-archive-keyring.gpg 2>> "${ACTVT_LOG_FILE}" || \
                error_exit "Failed to add Vector GPG keys"

            # Add Vector repository
            progress "Configuring Vector repository..."
            echo "deb [signed-by=/usr/share/keyrings/datadog-archive-keyring.gpg] https://apt.vector.dev/ stable vector-0" | \
                tee /etc/apt/sources.list.d/vector.list > /dev/null || \
                error_exit "Failed to add Vector repository"

            # Update package list
            progress "Updating package list..."
            ${PKG_UPDATE} >> "${ACTVT_LOG_FILE}" 2>&1

            # Install specific Vector version
            progress "Installing Vector ${VECTOR_VERSION}..."
            ${PKG_INSTALL} vector=${VECTOR_VERSION} >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to install Vector"
            ;;

        yum|dnf)
            # Add Datadog GPG keys
            progress "Adding Vector GPG keys..."
            rpm --import https://keys.datadoghq.com/DATADOG_RPM_KEY_CURRENT.public >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to import Vector GPG keys"

            # Add Vector repository
            progress "Configuring Vector repository..."
            cat > /etc/yum.repos.d/vector.repo << 'EOF'
[vector]
name=Vector
baseurl=https://yum.vector.dev/stable/vector-0/$basearch/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://keys.datadoghq.com/DATADOG_RPM_KEY_CURRENT.public
       https://keys.datadoghq.com/DATADOG_RPM_KEY_B01082D3.public
       https://keys.datadoghq.com/DATADOG_RPM_KEY_FD4BF915.public
EOF

            if [ $? -ne 0 ]; then
                error_exit "Failed to add Vector repository"
            fi

            # Install specific Vector version
            progress "Installing Vector ${VECTOR_VERSION}..."
            ${PKG_INSTALL} vector-${VECTOR_VERSION} >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to install Vector"
            ;;
    esac

    # Verify installation
    if ! command -v vector &> /dev/null; then
        error_exit "Vector installation failed"
    fi

    local vector_version=$(vector --version | grep -oP 'vector \K[0-9.]+' || echo "unknown")
    progress "Vector ${vector_version} installed successfully"

    # Verify systemd service
    if ! systemctl list-unit-files | grep -q vector.service; then
        log WARNING "Vector systemd service not found"
    fi

    # Verify vector user was created
    if ! id vector &> /dev/null; then
        log WARNING "Vector user not found, creating manually..."
        useradd -r -s /bin/false vector || true
    fi

    log SUCCESS "Vector installation complete"
}

###############################################################################
#                          Vector Configuration                               #
###############################################################################

configure_vector() {
    log STEP "Configuring Vector"

    # Detect GPU (inline check)
    local gpu_enabled="false"
    local gpu_detected=false
    if command -v nvidia-smi &> /dev/null && nvidia-smi &> /dev/null; then
        local gpu_name=$(nvidia-smi --query-gpu=name --format=csv,noheader | head -1)
        log INFO "NVIDIA GPU detected: ${gpu_name}"
        gpu_detected=true
    fi

    if [ "$gpu_detected" = true ]; then
        # Check environment variable first
        if [ -n "${ACTVT_ENABLE_GPU:-}" ]; then
            if [[ "${ACTVT_ENABLE_GPU}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                gpu_enabled="true"
                progress "GPU monitoring enabled (ACTVT_ENABLE_GPU=yes)"
            else
                progress "GPU monitoring disabled (ACTVT_ENABLE_GPU=${ACTVT_ENABLE_GPU})"
            fi
        # In non-interactive mode, enable by default if GPU detected
        elif ! is_interactive; then
            gpu_enabled="true"
            progress "GPU monitoring enabled (non-interactive mode, GPU detected)"
        # Interactive mode - prompt user
        else
            read -p "Enable GPU monitoring? [Y/n] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                gpu_enabled="true"
                progress "GPU monitoring will be enabled"
            fi
        fi
    fi

    # Backup existing configuration if it exists
    if [ -f "${VECTOR_CONFIG_DIR}/vector.toml" ]; then
        # Create backup with secure temporary filename (using mktemp for security)
        backup_file="$(mktemp -p "${ACTVT_BACKUP_DIR}" vector.toml.backup.XXXXXX)"
        if [ $? -ne 0 ]; then
            error_exit "Failed to create backup file"
        fi

        # Copy configuration to backup
        cp "${VECTOR_CONFIG_DIR}/vector.toml" "$backup_file" || \
            error_exit "Failed to backup existing configuration"

        progress "Existing configuration backed up to $(basename "$backup_file")"
    fi

    # Create Vector configuration directory
    mkdir -p "${VECTOR_CONFIG_DIR}"

    progress "Creating Vector configuration..."

    # Generate vector.toml
    cat > "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
###############################################################################
#                    vector.toml Production Configuration                     #
###############################################################################

################################ 1. SOURCES ###################################

[sources.system_metrics]
type                 = "host_metrics"
collectors           = ["cpu", "memory"]
scrape_interval_secs = 1

EOF

    # Add GPU configuration if enabled
    if [ "${gpu_enabled}" = "true" ]; then
        cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
# GPU metrics (requires nvidia-smi)
[sources.gpu_metrics]
type    = "exec"
command = [
  "nvidia-smi",
  "--query-gpu=utilization.gpu",
  "--format=csv,noheader,nounits"
]
mode = "scheduled"

[sources.gpu_metrics.scheduled]
exec_interval_secs = 1

EOF
    fi

    # Add transforms and sinks
    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
################################# 2. NORMALISE ################################

[transforms.metrics_to_logs]
type   = "metric_to_log"
inputs = ["system_metrics"]

EOF

    if [ "${gpu_enabled}" = "true" ]; then
        cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
[transforms.format_gpu]
type   = "remap"
inputs = ["gpu_metrics"]
source = '''
.metric_type = "gpu"
.value       = to_float!(.message)
.host        = get_env_var("HOSTNAME") ?? "unknown-host"
.timestamp   = format_timestamp!(now(), format: "%+")
'''

EOF
    fi

    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
[transforms.rewrite_mem_names]
type   = "remap"
inputs = ["metrics_to_logs"]
source = '''
if starts_with!(.name, "memory_") {
  .name = "host_" + to_string!(.name)
}
'''

################################ 3. FILTER & TAG ##############################

[transforms.format_metrics]
type   = "remap"
inputs = ["rewrite_mem_names"]
source = '''
# ----- derive a reliable host field -----
hostname = if !is_null(.host) {
             .host
           } else if !is_null(.tags.host) {
             .tags.host
           } else {
             get_env_var("HOSTNAME") ?? "unknown-host"
           }

# -------- filter + rename the metrics we care about --------
if .name == "host_memory_used_bytes" {
  .metric_type = "memory_used"
  .value       = .gauge.value
  .host        = hostname

} else if .name == "host_memory_total_bytes" {
  .metric_type = "memory_total"
  .value       = .gauge.value
  .host        = hostname

} else if (.name == "host_cpu_seconds_total" || .name == "cpu_seconds_total") && .tags.mode == "idle" {
  .metric_type = "cpu_idle"
  .value       = .counter.value
  .cpu         = .tags.cpu
  .host        = hostname

} else if (.name == "host_cpu_seconds_total" || .name == "cpu_seconds_total") {
  .metric_type = "cpu_total"
  .value       = .counter.value
  .cpu         = .tags.cpu
  .host        = hostname

} else {
  abort   # drop everything else
}

.timestamp = format_timestamp!(now(), format: "%+")
'''

################################ 4. PRODUCTION SINK ###########################

[sinks.websocket_out]
type    = "websocket_server"
EOF

    # Set inputs based on GPU configuration
    if [ "${gpu_enabled}" = "true" ]; then
        echo 'inputs  = ["format_metrics", "format_gpu"]' >> "${VECTOR_CONFIG_DIR}/vector.toml"
    else
        echo 'inputs  = ["format_metrics"]' >> "${VECTOR_CONFIG_DIR}/vector.toml"
    fi

    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
address = "0.0.0.0:4096"

encoding.codec            = "json"
encoding.timestamp_format = "rfc3339"

[sinks.websocket_out.tls]
enabled  = true
crt_file = "/etc/vector/certs/server.crt"
key_file = "/etc/vector/certs/server.key"

################################ 5. API #######################################

[api]
enabled = true
EOF

    # Set proper permissions
    chown -R vector:vector "${VECTOR_CONFIG_DIR}" || true
    chmod 644 "${VECTOR_CONFIG_DIR}/vector.toml"

    # Validate configuration (will fail if certs don't exist yet, but that's expected)
    progress "Validating configuration..."
    if vector validate "${VECTOR_CONFIG_DIR}/vector.toml" >> "${ACTVT_LOG_FILE}" 2>&1; then
        log SUCCESS "Vector configuration valid"
    else
        # Expected to fail without TLS certs
        log INFO "Configuration created (TLS certificates required before starting)"
    fi

    log SUCCESS "Vector configuration complete"
}

###############################################################################
#                           TLS Certificate Setup                             #
###############################################################################

setup_tls() {
    log STEP "Setting up TLS Certificates"

    # Use required domain from environment
    local domain="${ACTVT_DOMAIN}"
    log INFO "Using domain: ${domain:0:3}***${domain: -4}"

    # Verify DNS resolution
    progress "Verifying DNS resolution..."
    if ! host "${domain}" &> /dev/null; then
        log WARNING "Domain does not resolve. Please ensure DNS is configured correctly."
        log WARNING "Certificate acquisition may fail if DNS is not properly configured."

        # Check environment variable first
        if [ -n "${ACTVT_CONTINUE_WITHOUT_DNS:-}" ]; then
            if [[ "${ACTVT_CONTINUE_WITHOUT_DNS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                log WARNING "Continuing without DNS resolution (ACTVT_CONTINUE_WITHOUT_DNS=yes)"
            else
                error_exit "DNS not configured (ACTVT_CONTINUE_WITHOUT_DNS=${ACTVT_CONTINUE_WITHOUT_DNS})"
            fi
        # In non-interactive mode, fail by default
        elif ! is_interactive; then
            error_exit "DNS not configured (non-interactive mode). Set ACTVT_CONTINUE_WITHOUT_DNS=yes to override"
        # Interactive mode - prompt user
        else
            read -p "Continue anyway? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                error_exit "Please configure DNS and try again"
            fi
        fi
    fi

    # Install Certbot
    progress "Installing Certbot..."
    case "${PKG_MANAGER}" in
        apt-get)
            ${PKG_INSTALL} certbot >> "${ACTVT_LOG_FILE}" 2>&1
            ;;
        yum|dnf)
            # Enable EPEL repository for CentOS/RHEL
            if [ "${OS_NAME}" = "centos" ] || [ "${OS_NAME}" = "rhel" ]; then
                ${PKG_INSTALL} epel-release >> "${ACTVT_LOG_FILE}" 2>&1 || true
            fi
            ${PKG_INSTALL} certbot >> "${ACTVT_LOG_FILE}" 2>&1
            ;;
    esac

    if ! command -v certbot &> /dev/null; then
        error_exit "Failed to install Certbot"
    fi
    progress "Certbot installed successfully"

    # Use required email from environment
    local email="${ACTVT_EMAIL}"

    # Check if certificate already exists
    if [ -d "/etc/letsencrypt/live/${domain}" ]; then
        log INFO "Certificate for domain already exists"

        # Check environment variable first
        local reuse_cert="yes"
        if [ -n "${ACTVT_REUSE_CERT:-}" ]; then
            reuse_cert="${ACTVT_REUSE_CERT}"
        # In non-interactive mode, reuse by default
        elif ! is_interactive; then
            reuse_cert="yes"
        # Interactive mode - prompt user
        else
            read -p "Reuse existing certificate? [Y/n] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                reuse_cert="no"
            fi
        fi

        if [[ "${reuse_cert}" =~ ^[Yy]([Ee][Ss])?$ ]] || [[ "${reuse_cert}" == "yes" ]]; then
            progress "Using existing certificate"
        else
            progress "Obtaining new certificate..."
            certbot certonly --standalone -d "${domain}" \
                --email "${email}" --agree-tos --non-interactive --force-renewal \
                >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to obtain Let's Encrypt certificate"
        fi
    else
        progress "Obtaining Let's Encrypt certificate..."
        log INFO "This requires port 80 to be temporarily accessible"

        certbot certonly --standalone -d "${domain}" \
            --email "${email}" --agree-tos --non-interactive \
            >> "${ACTVT_LOG_FILE}" 2>&1 || \
            error_exit "Failed to obtain Let's Encrypt certificate. Ensure port 80 is accessible."
    fi

    # Copy certificates to Vector directory with secure permissions
    progress "Installing certificates for Vector..."

    # Set restrictive umask before creating sensitive files
    old_umask=$(umask)
    umask 077

    # Create Vector certs directory (inherits restrictive permissions)
    mkdir -p "${VECTOR_CERTS_DIR}"

    # Copy certificates (inherit restrictive permissions from umask)
    cp "/etc/letsencrypt/live/${domain}/fullchain.pem" "${VECTOR_CERTS_DIR}/server.crt" || \
        error_exit "Failed to copy certificate"
    cp "/etc/letsencrypt/live/${domain}/privkey.pem" "${VECTOR_CERTS_DIR}/server.key" || \
        error_exit "Failed to copy private key"

    # Restore original umask
    umask "$old_umask"

    # Set explicit permissions (private key already secure from umask)
    chmod 600 "${VECTOR_CERTS_DIR}/server.key"
    chmod 644 "${VECTOR_CERTS_DIR}/server.crt"

    # Set ownership on specific files (not recursive to avoid timing issues)
    chown vector:vector "${VECTOR_CERTS_DIR}/server.crt"
    chown vector:vector "${VECTOR_CERTS_DIR}/server.key"
    chown vector:vector "${VECTOR_CERTS_DIR}"

    progress "Certificates installed successfully"

    # Set up auto-renewal
    progress "Setting up automatic certificate renewal..."

    # Create renewal hook script
    local renewal_hook="/etc/letsencrypt/renewal-hooks/deploy/actvt-vector.sh"
    mkdir -p "$(dirname ${renewal_hook})"

    cat > "${renewal_hook}" << 'RENEWAL_EOF'
#!/bin/bash
# Copy renewed certificates to Vector directory with secure permissions

# Set restrictive umask before copying sensitive files
old_umask=$(umask)
umask 077

# Copy certificates (inherit restrictive permissions from umask)
cp "/etc/letsencrypt/live/${RENEWED_LINEAGE##*/}/fullchain.pem" /etc/vector/certs/server.crt
cp "/etc/letsencrypt/live/${RENEWED_LINEAGE##*/}/privkey.pem" /etc/vector/certs/server.key

# Restore original umask
umask "$old_umask"

# Set explicit permissions
chmod 600 /etc/vector/certs/server.key
chmod 644 /etc/vector/certs/server.crt

# Set ownership on specific files
chown vector:vector /etc/vector/certs/server.crt
chown vector:vector /etc/vector/certs/server.key

# Reload or restart Vector service and verify it's running
if systemctl reload vector 2>/dev/null; then
    # Wait for reload to complete
    sleep 1
elif systemctl restart vector; then
    # Wait for restart to complete (poll up to 30 seconds)
    wait_count=0
    while ! systemctl is-active --quiet vector && [ $wait_count -lt 30 ]; do
        sleep 1
        wait_count=$((wait_count + 1))
    done
fi

# Verify service is running after reload/restart
if ! systemctl is-active --quiet vector; then
    logger -t actvt-renewal "ERROR: Vector service failed to start after certificate renewal"
    exit 1
fi
RENEWAL_EOF

    chmod +x "${renewal_hook}"

    # Test renewal (dry-run)
    if certbot renew --dry-run >> "${ACTVT_LOG_FILE}" 2>&1; then
        progress "Auto-renewal configured successfully"
    else
        log WARNING "Auto-renewal test failed, but certificates are installed"
    fi

    # Store domain for later use
    echo "${domain}" > "${ACTVT_STATE_DIR}/domain"

    log SUCCESS "TLS certificates configured successfully"
}

###############################################################################
#                          Firewall Configuration                             #
###############################################################################

configure_firewall() {
    log STEP "Configuring Firewall"

    # Check if firewall configuration should be skipped
    local configure_fw="yes"
    if [ -n "${ACTVT_CONFIGURE_FIREWALL:-}" ]; then
        configure_fw="${ACTVT_CONFIGURE_FIREWALL}"
    elif ! is_interactive; then
        configure_fw="yes"
    fi

    if [[ ! "${configure_fw}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        log INFO "Skipping firewall configuration (ACTVT_CONFIGURE_FIREWALL=${configure_fw})"
        log INFO "Please ensure ports 80, 443, and 4096 are accessible"
        return 0
    fi

    # Detect firewall
    local firewall_type=""
    if command -v ufw &> /dev/null; then
        firewall_type="ufw"
    elif command -v firewall-cmd &> /dev/null; then
        firewall_type="firewalld"
    elif command -v iptables &> /dev/null; then
        firewall_type="iptables"
    else
        log WARNING "No firewall detected. Please configure firewall manually."
        log INFO "Required ports: 80 (HTTP), 443 (HTTPS), 4096 (WebSocket)"
        return 0
    fi

    progress "Detected firewall: ${firewall_type}"

    case "${firewall_type}" in
        ufw)
            progress "Configuring UFW..."

            # Enable UFW if not already enabled
            if ! ufw status | grep -q "Status: active"; then
                log WARNING "UFW is not active. Enabling UFW..."
                # Allow SSH first to prevent lockout
                ufw allow 22/tcp >> "${ACTVT_LOG_FILE}" 2>&1
                ufw --force enable >> "${ACTVT_LOG_FILE}" 2>&1
            fi

            # Allow required ports
            ufw allow 80/tcp >> "${ACTVT_LOG_FILE}" 2>&1
            ufw allow 443/tcp >> "${ACTVT_LOG_FILE}" 2>&1
            ufw allow 4096/tcp >> "${ACTVT_LOG_FILE}" 2>&1

            progress "Firewall rules added"
            ;;

        firewalld)
            progress "Configuring firewalld..."

            # Start firewalld if not running
            if ! systemctl is-active --quiet firewalld; then
                systemctl start firewalld
            fi

            # Allow required ports
            firewall-cmd --permanent --add-port=80/tcp >> "${ACTVT_LOG_FILE}" 2>&1
            firewall-cmd --permanent --add-port=443/tcp >> "${ACTVT_LOG_FILE}" 2>&1
            firewall-cmd --permanent --add-port=4096/tcp >> "${ACTVT_LOG_FILE}" 2>&1
            firewall-cmd --reload >> "${ACTVT_LOG_FILE}" 2>&1

            progress "Firewall rules added"
            ;;

        iptables)
            progress "Configuring iptables..."

            # Add rules if they don't exist
            iptables -C INPUT -p tcp --dport 80 -j ACCEPT 2>/dev/null || \
                iptables -I INPUT -p tcp --dport 80 -j ACCEPT
            iptables -C INPUT -p tcp --dport 443 -j ACCEPT 2>/dev/null || \
                iptables -I INPUT -p tcp --dport 443 -j ACCEPT
            iptables -C INPUT -p tcp --dport 4096 -j ACCEPT 2>/dev/null || \
                iptables -I INPUT -p tcp --dport 4096 -j ACCEPT

            # Try to save rules
            if command -v iptables-save &> /dev/null; then
                iptables-save > /etc/iptables/rules.v4 2>/dev/null || \
                    log WARNING "Could not persist iptables rules. They may not survive reboot."
            fi

            progress "Firewall rules added"
            ;;
    esac

    log SUCCESS "Firewall configuration complete"
}

###############################################################################
#                          Service Management                                 #
###############################################################################

start_vector_service() {
    log STEP "Starting Vector Service"

    # Stop Vector if running (to clear any demo/default config)
    if systemctl is-active --quiet vector; then
        progress "Stopping existing Vector service..."
        systemctl stop vector >> "${ACTVT_LOG_FILE}" 2>&1 || true

        # Wait for service to fully stop (poll up to 30 seconds)
        local wait_count=0
        while systemctl is-active --quiet vector && [ $wait_count -lt 30 ]; do
            sleep 1
            wait_count=$((wait_count + 1))
        done

        if systemctl is-active --quiet vector; then
            log WARNING "Service did not stop cleanly, forcing stop..."
            systemctl kill vector >> "${ACTVT_LOG_FILE}" 2>&1 || true
            sleep 2
        else
            progress "Service stopped successfully"
        fi
    fi

    # Create systemd override to explicitly use our config file
    progress "Configuring Vector service to use /etc/vector/vector.toml..."
    mkdir -p /etc/systemd/system/vector.service.d
    cat > /etc/systemd/system/vector.service.d/override.conf << 'OVERRIDE_EOF'
[Service]
ExecStart=
ExecStart=/usr/bin/vector --config /etc/vector/vector.toml
OVERRIDE_EOF

    # Reload systemd daemon to pick up changes
    progress "Reloading systemd daemon..."
    systemctl daemon-reload >> "${ACTVT_LOG_FILE}" 2>&1

    # Enable systemd service
    progress "Enabling Vector service..."
    systemctl enable vector >> "${ACTVT_LOG_FILE}" 2>&1

    # Start service
    progress "Starting Vector with custom configuration..."
    if systemctl start vector >> "${ACTVT_LOG_FILE}" 2>&1; then
        progress "Vector service start command issued"
    else
        log ERROR "Failed to start Vector service"
        log INFO "Checking service status..."
        systemctl status vector --no-pager >> "${ACTVT_LOG_FILE}" 2>&1 || true
        error_exit "Vector service failed to start. Check logs: journalctl -u vector -n 50"
    fi

    # Wait for service to become active (poll up to 30 seconds)
    progress "Waiting for Vector service to become active..."
    local wait_count=0
    while ! systemctl is-active --quiet vector && [ $wait_count -lt 30 ]; do
        sleep 1
        wait_count=$((wait_count + 1))
    done

    # Verify service is running
    if ! systemctl is-active --quiet vector; then
        log ERROR "Vector service did not start within 30 seconds"
        systemctl status vector --no-pager >> "${ACTVT_LOG_FILE}" 2>&1 || true
        error_exit "Vector service is not running"
    fi

    progress "Vector service is active"

    # Give service a moment to fully initialize before checking logs
    sleep 2

    # Verify it's not running demo configuration
    if journalctl -u vector -n 20 --no-pager 2>/dev/null | grep -q "BronzeGamer\|meln1ks\|We're gonna need a bigger boat"; then
        log WARNING "Vector appears to be running with demo configuration, attempting restart..."
        systemctl restart vector >> "${ACTVT_LOG_FILE}" 2>&1 || true

        # Wait for restart to complete (poll up to 30 seconds)
        wait_count=0
        while ! systemctl is-active --quiet vector && [ $wait_count -lt 30 ]; do
            sleep 1
            wait_count=$((wait_count + 1))
        done

        if ! systemctl is-active --quiet vector; then
            error_exit "Vector service failed to restart"
        fi

        progress "Vector service restarted successfully"
    fi

    log SUCCESS "Vector service started and enabled"
}

###############################################################################
#                          Validation & Testing                               #
###############################################################################

validate_installation() {
    log STEP "Validating Installation"

    # Check Vector is running
    progress "Checking Vector service..."
    if systemctl is-active --quiet vector; then
        progress "Vector service: Running ✓"
    else
        log ERROR "Vector service is not running"
        return 1
    fi

    # Check port 4096 is listening
    progress "Checking WebSocket port..."
    if netstat -tuln 2>/dev/null | grep -q ":4096 " || \
       ss -tuln 2>/dev/null | grep -q ":4096 "; then
        progress "Port 4096: Listening ✓"
    else
        log WARNING "Port 4096 is not listening yet (may take a moment)"
    fi

    # Check TLS certificates exist and are valid
    progress "Checking TLS certificates..."
    if [ -f "${VECTOR_CERTS_DIR}/server.crt" ] && [ -f "${VECTOR_CERTS_DIR}/server.key" ]; then
        local cert_expiry=$(openssl x509 -in "${VECTOR_CERTS_DIR}/server.crt" -noout -enddate 2>/dev/null | cut -d= -f2)
        progress "TLS certificates: Valid until ${cert_expiry} ✓"
    else
        log ERROR "TLS certificates not found"
        return 1
    fi

    # Get domain from state file
    local domain=""
    if [ -f "${ACTVT_STATE_DIR}/domain" ]; then
        domain=$(cat "${ACTVT_STATE_DIR}/domain")
    fi

    log SUCCESS "Installation validation complete"

    # Display connection information
    echo
    echo -e "${GREEN}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}${BOLD}  Installation Complete!${NC}"
    echo -e "${GREEN}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
    echo -e "${BOLD}WebSocket URL:${NC}"
    if [ -n "${domain}" ]; then
        echo -e "  ${CYAN}wss://${domain}:4096${NC}"
    else
        echo -e "  ${CYAN}wss://YOUR_DOMAIN:4096${NC}"
    fi
    echo
    echo -e "${BOLD}Next Steps:${NC}"
    echo -e "  1. Open Actvt on your Mac"
    echo -e "  2. Go to Settings → Remote Servers"
    echo -e "  3. Add a new server with the WebSocket URL above"
    echo -e "  4. Start monitoring your remote server!"
    echo
    echo -e "${BOLD}Service Management:${NC}"
    echo -e "  • Check status:  ${CYAN}sudo systemctl status vector${NC}"
    echo -e "  • View logs:     ${CYAN}sudo journalctl -u vector -f${NC}"
    echo -e "  • Restart:       ${CYAN}sudo systemctl restart vector${NC}"
    echo
    echo -e "${BOLD}Documentation:${NC}"
    echo -e "  ${CYAN}https://actvt.io/docs/remote-server/overview${NC}"
    echo
    echo -e "${GREEN}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
}

###############################################################################
#                              Main Execution                                 #
###############################################################################

main() {
    # Clear screen and show banner
    clear
    echo -e "${CYAN}${BOLD}"
    echo "╔═══════════════════════════════════════════════════════════════╗"
    echo "║                                                               ║"
    echo "║           Actvt Remote Server Installation Script            ║"
    echo "║                      Version ${SCRIPT_VERSION}                        ║"
    echo "║                                                               ║"
    echo "╚═══════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    echo

    # Validate and create state directories
    # Validate state directory path to prevent path traversal
    if [[ ! "${ACTVT_STATE_DIR}" =~ ^/var/lib/actvt$ ]]; then
        echo "ERROR: Invalid state directory path: ${ACTVT_STATE_DIR}" >&2
        exit 1
    fi

    # Validate backup directory path to prevent path traversal
    if [[ ! "${ACTVT_BACKUP_DIR}" =~ ^/var/lib/actvt/backups$ ]]; then
        echo "ERROR: Invalid backup directory path: ${ACTVT_BACKUP_DIR}" >&2
        exit 1
    fi

    # Create directories with restrictive permissions
    mkdir -p "${ACTVT_STATE_DIR}"
    chmod 700 "${ACTVT_STATE_DIR}"
    mkdir -p "${ACTVT_BACKUP_DIR}"
    chmod 700 "${ACTVT_BACKUP_DIR}"

    # Initialize log file
    touch "${ACTVT_LOG_FILE}" 2>/dev/null || ACTVT_LOG_FILE="/tmp/actvt-install.log"
    chmod 600 "${ACTVT_LOG_FILE}"

    log INFO "Starting Actvt installation (version ${SCRIPT_VERSION})"
    log INFO "Log file: ${ACTVT_LOG_FILE}"

    # Run installation steps
    detect_os
    check_requirements
    install_vector
    configure_vector
    setup_tls
    configure_firewall
    start_vector_service
    validate_installation

    # Save installation state
    echo "version=${SCRIPT_VERSION}" > "${ACTVT_STATE_DIR}/install.state"
    echo "installed_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "${ACTVT_STATE_DIR}/install.state"

    log INFO "Installation completed successfully"
}

# Run main function
main "$@"
