#!/usr/bin/env bash
###############################################################################
#                    Actvt Remote Server Installation Script                  #
###############################################################################
#
# Description: Automated installation script for Actvt remote server monitoring
#
# Required environment variables:
#   ACTVT_DOMAIN - Your server domain name (e.g., monitor.yourdomain.com)
#   ACTVT_EMAIL  - Email address for Let's Encrypt notifications
#
# Optional environment variables:
#   ACTVT_INSTALL_MODE       - Installation mode: auto|standalone|proxy (default: auto)
#   ACTVT_VECTOR_PORT        - Port for Vector WebSocket server (default: 4096)
#   ACTVT_NGINX_WEBROOT      - Nginx webroot for certificate validation (default: /var/www/html)
#   ACTVT_FORCE_STANDALONE   - Force standalone mode even if web server detected (default: no)
#   ACTVT_CONFIGURE_FIREWALL - Configure firewall rules (default: yes)
#
# Installation Modes:
#   - auto: Automatically detect existing web server and choose appropriate mode
#   - standalone: Fresh server installation (Vector exposed on port 4096)
#   - proxy: Install behind existing nginx (Vector on localhost, nginx proxies /actvt path)
#
# Usage (basic):
#   export ACTVT_DOMAIN=monitor.yourdomain.com
#   export ACTVT_EMAIL=admin@yourdomain.com
#   curl -L https://actvt.io/install | bash
#
# Usage (with nginx reverse proxy):
#   export ACTVT_DOMAIN=monitor.yourdomain.com
#   export ACTVT_EMAIL=admin@yourdomain.com
#   export ACTVT_INSTALL_MODE=proxy
#   curl -L https://actvt.io/install | bash
#
# Documentation: https://actvt.io/docs/remote-server/overview
#
# Version: 1.0.0
# Last Updated: 2025-10-08
#
###############################################################################

set -euo pipefail

# Script version
readonly SCRIPT_VERSION="1.0.0"

# Installation mode configuration
# ACTVT_INSTALL_MODE:
#   - "auto" (default): Detect and choose appropriate mode
#   - "standalone": Dedicated server, ports 80/443/4096 exposed directly
#   - "proxy": Behind existing nginx, localhost-only binding
readonly ACTVT_INSTALL_MODE="${ACTVT_INSTALL_MODE:-auto}"
readonly ACTVT_VECTOR_PORT="${ACTVT_VECTOR_PORT:-4096}"
readonly ACTVT_NGINX_WEBROOT="${ACTVT_NGINX_WEBROOT:-/var/www/html}"
readonly ACTVT_FORCE_STANDALONE="${ACTVT_FORCE_STANDALONE:-no}"

# Global variables for detected state
EXISTING_WEBSERVER=""
SELECTED_MODE=""

# Installation directories
readonly ACTVT_STATE_DIR="/var/lib/actvt"
readonly ACTVT_LOG_FILE="/var/log/actvt-install.log"
readonly ACTVT_BACKUP_DIR="${ACTVT_STATE_DIR}/backups"
readonly VECTOR_CONFIG_DIR="/etc/vector"
readonly VECTOR_CERTS_DIR="${VECTOR_CONFIG_DIR}/certs"

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color
readonly BOLD='\033[1m'

# Progress tracking
CURRENT_STEP=0
TOTAL_STEPS=9

###############################################################################
#                           Logging Functions                                 #
###############################################################################

log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Log to file
    echo "[${timestamp}] [${level}] ${message}" >> "${ACTVT_LOG_FILE}" 2>/dev/null || true

    # Log to console with colors
    case "${level}" in
        INFO)
            echo -e "${BLUE}ℹ${NC} ${message}"
            ;;
        SUCCESS)
            echo -e "${GREEN}✓${NC} ${message}"
            ;;
        WARNING)
            echo -e "${YELLOW}⚠${NC} ${message}"
            ;;
        ERROR)
            echo -e "${RED}✗${NC} ${message}"
            ;;
        STEP)
            CURRENT_STEP=$((CURRENT_STEP + 1))
            echo -e "\n${CYAN}${BOLD}[${CURRENT_STEP}/${TOTAL_STEPS}]${NC} ${BOLD}${message}${NC}"
            ;;
    esac
}

progress() {
    echo -e "${CYAN}  →${NC} $*"
}

###############################################################################
#                           Error Handling                                    #
###############################################################################

cleanup() {
    local exit_code=$?
    if [ ${exit_code} -ne 0 ]; then
        log ERROR "Installation failed with exit code ${exit_code}"
        log ERROR "Check the log file at ${ACTVT_LOG_FILE} for details"
        log INFO "You can try running the script again or follow the manual installation guide"
        log INFO "Documentation: https://actvt.io/docs/remote-server/overview"
    fi
}

trap cleanup EXIT

error_exit() {
    log ERROR "$1"
    exit 1
}

###############################################################################
#                        Interactive Mode Detection                           #
###############################################################################

is_interactive() {
    # Check if explicitly set to non-interactive
    if [ "${ACTVT_NON_INTERACTIVE:-}" = "yes" ]; then
        return 1
    fi
    # Check if stdin is a terminal
    [ -t 0 ]
}

###############################################################################
#                           OS Detection                                      #
###############################################################################

detect_os() {
    log STEP "Detecting Operating System"

    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS_NAME="${ID}"
        OS_VERSION="${VERSION_ID}"
        OS_PRETTY_NAME="${PRETTY_NAME}"
    elif [ -f /etc/lsb-release ]; then
        . /etc/lsb-release
        OS_NAME="${DISTRIB_ID,,}"
        OS_VERSION="${DISTRIB_RELEASE}"
        OS_PRETTY_NAME="${DISTRIB_DESCRIPTION}"
    elif [ -f /etc/redhat-release ]; then
        OS_NAME="rhel"
        OS_VERSION=$(cat /etc/redhat-release | grep -oP '\d+\.\d+' | head -1)
        OS_PRETTY_NAME=$(cat /etc/redhat-release)
    else
        error_exit "Unsupported operating system. Supported: Ubuntu, Debian, CentOS, RHEL, Amazon Linux"
    fi

    progress "Detected: ${OS_PRETTY_NAME}"

    # Determine package manager
    case "${OS_NAME}" in
        ubuntu|debian)
            PKG_MANAGER="apt-get"
            PKG_UPDATE="apt-get update"
            PKG_INSTALL="apt-get install -y"
            ;;
        centos|rhel)
            if command -v dnf &> /dev/null; then
                PKG_MANAGER="dnf"
                PKG_UPDATE="dnf check-update || true"
                PKG_INSTALL="dnf install -y"
            else
                PKG_MANAGER="yum"
                PKG_UPDATE="yum check-update || true"
                PKG_INSTALL="yum install -y"
            fi
            ;;
        amzn|amazonlinux)
            PKG_MANAGER="yum"
            PKG_UPDATE="yum check-update || true"
            PKG_INSTALL="yum install -y"
            ;;
        *)
            error_exit "Unsupported distribution: ${OS_NAME}"
            ;;
    esac

    progress "Package manager: ${PKG_MANAGER}"
    log SUCCESS "OS detection complete"
}

###############################################################################
#                        System Requirements Check                            #
###############################################################################

check_requirements() {
    log STEP "Checking System Requirements"

    # Check if running as root or with sudo
    if [ "$EUID" -ne 0 ]; then
        error_exit "This script must be run as root or with sudo"
    fi

    # Check required environment variables
    if [ -z "${ACTVT_DOMAIN:-}" ]; then
        error_exit "ACTVT_DOMAIN environment variable is required. Example: export ACTVT_DOMAIN=monitor.yourdomain.com"
    fi

    if [ -z "${ACTVT_EMAIL:-}" ]; then
        error_exit "ACTVT_EMAIL environment variable is required. Example: export ACTVT_EMAIL=admin@yourdomain.com"
    fi

    # Validate domain format (RFC 1123 compliant)
    if ! [[ "${ACTVT_DOMAIN}" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
        error_exit "Invalid domain format. Must be a valid hostname (e.g., monitor.example.com)"
    fi

    # Validate email format (RFC 5322 basic)
    if ! [[ "${ACTVT_EMAIL}" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        error_exit "Invalid email format. Must be a valid email address"
    fi

    # Redact sensitive information in logs (show partial for verification)
    progress "Domain: ${ACTVT_DOMAIN:0:3}***${ACTVT_DOMAIN: -4}"
    progress "Email: ${ACTVT_EMAIL%%@*}@***"

    # DNS Configuration Warning
    log WARNING "IMPORTANT: DNS Configuration Required"
    log WARNING "Your domain must have an A or CNAME record pointing to this server"
    log WARNING "pointing to this server's IP address for Let's Encrypt to work."
    log WARNING "Without proper DNS configuration, certificate acquisition will fail."

    # Check available disk space (need at least 100MB)
    local available_space=$(df /tmp | tail -1 | awk '{print $4}')
    if [ "${available_space}" -lt 102400 ]; then
        error_exit "Insufficient disk space. Need at least 100MB free"
    fi
    progress "Disk space: OK ($(numfmt --to=iec-i --suffix=B $((available_space * 1024))))"

    # Check available memory (need at least 512MB)
    local available_mem=$(free -m | awk '/^Mem:/{print $2}')
    if [ "${available_mem}" -lt 512 ]; then
        log WARNING "Low memory detected (${available_mem}MB). Recommended: 1GB+"
    else
        progress "Memory: OK (${available_mem}MB)"
    fi

    # Check internet connectivity
    if ! ping -c 1 -W 2 8.8.8.8 &> /dev/null; then
        error_exit "No internet connectivity detected"
    fi

    # Check if required commands are available
    for cmd in curl tar; do
        if ! command -v ${cmd} &> /dev/null; then
            progress "Installing ${cmd}..."
            ${PKG_INSTALL} ${cmd} >> "${ACTVT_LOG_FILE}" 2>&1
        fi
    done

    log SUCCESS "All system requirements met"
}

###############################################################################
#                           Vector Installation                               #
###############################################################################

install_vector() {
    log STEP "Installing Vector"

    # Check if Vector is already installed
    if command -v vector &> /dev/null; then
        local installed_version=$(vector --version | grep -oP 'vector \K[0-9.]+' || echo "unknown")
        log INFO "Vector is already installed (version ${installed_version})"

        # Check environment variable first
        if [ -n "${ACTVT_REINSTALL_VECTOR:-}" ]; then
            if [[ "${ACTVT_REINSTALL_VECTOR}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                progress "Reinstalling Vector (ACTVT_REINSTALL_VECTOR=yes)"
            else
                log INFO "Skipping Vector installation (ACTVT_REINSTALL_VECTOR=${ACTVT_REINSTALL_VECTOR})"
                return 0
            fi
        # In non-interactive mode, skip by default
        elif ! is_interactive; then
            log INFO "Skipping Vector installation (non-interactive mode)"
            return 0
        # Interactive mode - prompt user
        else
            read -p "Do you want to reinstall/update Vector? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log INFO "Skipping Vector installation"
                return 0
            fi
        fi
    fi

    # Vector version to install
    readonly VECTOR_VERSION="0.50.0-1"

    progress "Adding Vector repository..."

    case "${PKG_MANAGER}" in
        apt-get)
            # Install required packages for repository management
            progress "Installing repository dependencies..."
            ${PKG_INSTALL} apt-transport-https gnupg ca-certificates curl >> "${ACTVT_LOG_FILE}" 2>&1

            # Add Datadog GPG keys for package verification
            progress "Adding Vector GPG keys..."
            curl -fsSL https://keys.datadoghq.com/DATADOG_APT_KEY_CURRENT.public 2>> "${ACTVT_LOG_FILE}" | \
                gpg --dearmor -o /usr/share/keyrings/datadog-archive-keyring.gpg 2>> "${ACTVT_LOG_FILE}" || \
                error_exit "Failed to add Vector GPG keys"

            # Add Vector repository
            progress "Configuring Vector repository..."
            echo "deb [signed-by=/usr/share/keyrings/datadog-archive-keyring.gpg] https://apt.vector.dev/ stable vector-0" | \
                tee /etc/apt/sources.list.d/vector.list > /dev/null || \
                error_exit "Failed to add Vector repository"

            # Update package list
            progress "Updating package list..."
            ${PKG_UPDATE} >> "${ACTVT_LOG_FILE}" 2>&1

            # Install specific Vector version
            progress "Installing Vector ${VECTOR_VERSION}..."
            ${PKG_INSTALL} vector=${VECTOR_VERSION} >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to install Vector"
            ;;

        yum|dnf)
            # Add Datadog GPG keys
            progress "Adding Vector GPG keys..."
            rpm --import https://keys.datadoghq.com/DATADOG_RPM_KEY_CURRENT.public >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to import Vector GPG keys"

            # Add Vector repository
            progress "Configuring Vector repository..."
            cat > /etc/yum.repos.d/vector.repo << 'EOF'
[vector]
name=Vector
baseurl=https://yum.vector.dev/stable/vector-0/$basearch/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://keys.datadoghq.com/DATADOG_RPM_KEY_CURRENT.public
       https://keys.datadoghq.com/DATADOG_RPM_KEY_B01082D3.public
       https://keys.datadoghq.com/DATADOG_RPM_KEY_FD4BF915.public
EOF

            if [ $? -ne 0 ]; then
                error_exit "Failed to add Vector repository"
            fi

            # Install specific Vector version
            progress "Installing Vector ${VECTOR_VERSION}..."
            ${PKG_INSTALL} vector-${VECTOR_VERSION} >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to install Vector"
            ;;
    esac

    # Verify installation
    if ! command -v vector &> /dev/null; then
        error_exit "Vector installation failed"
    fi

    local vector_version=$(vector --version | grep -oP 'vector \K[0-9.]+' || echo "unknown")
    progress "Vector ${vector_version} installed successfully"

    # Verify systemd service
    if ! systemctl list-unit-files | grep -q vector.service; then
        log WARNING "Vector systemd service not found"
    fi

    # Verify vector user was created
    if ! id vector &> /dev/null; then
        log WARNING "Vector user not found, creating manually..."
        useradd -r -s /bin/false vector || true
    fi

    log SUCCESS "Vector installation complete"
}

###############################################################################
#                          Vector Configuration                               #
###############################################################################

configure_vector() {
    log STEP "Configuring Vector"

    # Detect GPU (inline check)
    local gpu_enabled="false"
    local gpu_detected=false
    if command -v nvidia-smi &> /dev/null && nvidia-smi &> /dev/null; then
        local gpu_name=$(nvidia-smi --query-gpu=name --format=csv,noheader | head -1)
        log INFO "NVIDIA GPU detected: ${gpu_name}"
        gpu_detected=true
    fi

    if [ "$gpu_detected" = true ]; then
        # Check environment variable first
        if [ -n "${ACTVT_ENABLE_GPU:-}" ]; then
            if [[ "${ACTVT_ENABLE_GPU}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                gpu_enabled="true"
                progress "GPU monitoring enabled (ACTVT_ENABLE_GPU=yes)"
            else
                progress "GPU monitoring disabled (ACTVT_ENABLE_GPU=${ACTVT_ENABLE_GPU})"
            fi
        # In non-interactive mode, enable by default if GPU detected
        elif ! is_interactive; then
            gpu_enabled="true"
            progress "GPU monitoring enabled (non-interactive mode, GPU detected)"
        # Interactive mode - prompt user
        else
            read -p "Enable GPU monitoring? [Y/n] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                gpu_enabled="true"
                progress "GPU monitoring will be enabled"
            fi
        fi
    fi

    # Backup existing configuration if it exists
    if [ -f "${VECTOR_CONFIG_DIR}/vector.toml" ]; then
        # Create backup with secure temporary filename (using mktemp for security)
        backup_file="$(mktemp -p "${ACTVT_BACKUP_DIR}" vector.toml.backup.XXXXXX)"
        if [ $? -ne 0 ]; then
            error_exit "Failed to create backup file"
        fi

        # Copy configuration to backup
        cp "${VECTOR_CONFIG_DIR}/vector.toml" "$backup_file" || \
            error_exit "Failed to backup existing configuration"

        progress "Existing configuration backed up to $(basename "$backup_file")"
    fi

    # Create Vector configuration directory
    mkdir -p "${VECTOR_CONFIG_DIR}"

    progress "Creating Vector configuration..."

    # Generate vector.toml
    cat > "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
###############################################################################
#                    vector.toml Production Configuration                     #
###############################################################################

################################ 1. SOURCES ###################################

[sources.system_metrics]
type                 = "host_metrics"
collectors           = ["cpu", "memory"]
scrape_interval_secs = 1

EOF

    # Add GPU configuration if enabled
    if [ "${gpu_enabled}" = "true" ]; then
        cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
# GPU metrics (requires nvidia-smi)
[sources.gpu_metrics]
type    = "exec"
command = [
  "nvidia-smi",
  "--query-gpu=utilization.gpu",
  "--format=csv,noheader,nounits"
]
mode = "scheduled"

[sources.gpu_metrics.scheduled]
exec_interval_secs = 1

EOF
    fi

    # Add transforms and sinks
    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
################################# 2. NORMALISE ################################

[transforms.metrics_to_logs]
type   = "metric_to_log"
inputs = ["system_metrics"]

EOF

    if [ "${gpu_enabled}" = "true" ]; then
        cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
[transforms.format_gpu]
type   = "remap"
inputs = ["gpu_metrics"]
source = '''
.metric_type = "gpu"
.value       = to_float!(.message)
.host        = get_env_var("HOSTNAME") ?? "unknown-host"
.timestamp   = format_timestamp!(now(), format: "%+")
'''

EOF
    fi

    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
[transforms.rewrite_mem_names]
type   = "remap"
inputs = ["metrics_to_logs"]
source = '''
if starts_with!(.name, "memory_") {
  .name = "host_" + to_string!(.name)
}
'''

################################ 3. FILTER & TAG ##############################

[transforms.format_metrics]
type   = "remap"
inputs = ["rewrite_mem_names"]
source = '''
# ----- derive a reliable host field -----
hostname = if !is_null(.host) {
             .host
           } else if !is_null(.tags.host) {
             .tags.host
           } else {
             get_env_var("HOSTNAME") ?? "unknown-host"
           }

# -------- filter + rename the metrics we care about --------
if .name == "host_memory_used_bytes" {
  .metric_type = "memory_used"
  .value       = .gauge.value
  .host        = hostname

} else if .name == "host_memory_total_bytes" {
  .metric_type = "memory_total"
  .value       = .gauge.value
  .host        = hostname

} else if (.name == "host_cpu_seconds_total" || .name == "cpu_seconds_total") && .tags.mode == "idle" {
  .metric_type = "cpu_idle"
  .value       = .counter.value
  .cpu         = .tags.cpu
  .host        = hostname

} else if (.name == "host_cpu_seconds_total" || .name == "cpu_seconds_total") {
  .metric_type = "cpu_total"
  .value       = .counter.value
  .cpu         = .tags.cpu
  .host        = hostname

} else {
  abort   # drop everything else
}

.timestamp = format_timestamp!(now(), format: "%+")
'''

################################ 4. PRODUCTION SINK ###########################

[sinks.websocket_out]
type    = "websocket_server"
EOF

    # Set inputs based on GPU configuration
    if [ "${gpu_enabled}" = "true" ]; then
        echo 'inputs  = ["format_metrics", "format_gpu"]' >> "${VECTOR_CONFIG_DIR}/vector.toml"
    else
        echo 'inputs  = ["format_metrics"]' >> "${VECTOR_CONFIG_DIR}/vector.toml"
    fi

    # Set bind address based on installation mode
    # In proxy mode, bind to localhost only; in standalone, bind to all interfaces
    local bind_address="0.0.0.0:${ACTVT_VECTOR_PORT}"
    if [ "$SELECTED_MODE" = "proxy" ]; then
        bind_address="127.0.0.1:${ACTVT_VECTOR_PORT}"
        progress "Vector will bind to localhost only (proxy mode)"
    else
        progress "Vector will bind to all interfaces (standalone mode)"
    fi

    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << EOF
address = "${bind_address}"

encoding.codec            = "json"
encoding.timestamp_format = "rfc3339"
EOF

    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'

[sinks.websocket_out.tls]
enabled  = true
crt_file = "/etc/vector/certs/server.crt"
key_file = "/etc/vector/certs/server.key"

################################ 5. API #######################################

[api]
enabled = true
EOF

    # Set proper permissions
    chown -R vector:vector "${VECTOR_CONFIG_DIR}" || true
    chmod 644 "${VECTOR_CONFIG_DIR}/vector.toml"

    # Validate configuration (will fail if certs don't exist yet, but that's expected)
    progress "Validating configuration..."
    if vector validate "${VECTOR_CONFIG_DIR}/vector.toml" >> "${ACTVT_LOG_FILE}" 2>&1; then
        log SUCCESS "Vector configuration valid"
    else
        # Expected to fail without TLS certs
        log INFO "Configuration created (TLS certificates required before starting)"
    fi

    log SUCCESS "Vector configuration complete"
}

###############################################################################
#                        Web Server Detection                                 #
###############################################################################

detect_existing_webserver() {
    log INFO "Checking for existing web server..."

    # Check if ports 80 or 443 are in use
    local port_80_in_use=false
    local port_443_in_use=false

    # Try lsof first, fallback to ss
    if command -v lsof &> /dev/null; then
        if lsof -ti:80 &> /dev/null; then
            port_80_in_use=true
        fi
        if lsof -ti:443 &> /dev/null; then
            port_443_in_use=true
        fi
    elif command -v ss &> /dev/null; then
        if ss -tlnp 2>/dev/null | grep -q ':80 '; then
            port_80_in_use=true
        fi
        if ss -tlnp 2>/dev/null | grep -q ':443 '; then
            port_443_in_use=true
        fi
    fi

    # Detect which web server is running
    if [ "$port_80_in_use" = true ] || [ "$port_443_in_use" = true ]; then
        if systemctl is-active --quiet nginx 2>/dev/null || pgrep nginx &> /dev/null; then
            EXISTING_WEBSERVER="nginx"
            progress "Nginx detected on port 80/443"
            return 0
        elif systemctl is-active --quiet apache2 2>/dev/null || pgrep apache2 &> /dev/null; then
            EXISTING_WEBSERVER="apache"
            progress "Apache detected on port 80/443"
            return 0
        elif systemctl is-active --quiet httpd 2>/dev/null || pgrep httpd &> /dev/null; then
            EXISTING_WEBSERVER="httpd"
            progress "Apache/httpd detected on port 80/443"
            return 0
        else
            EXISTING_WEBSERVER="unknown"
            log WARNING "Unknown service using port 80/443"
            return 0
        fi
    fi

    progress "No existing web server detected"
    return 0
}

determine_installation_mode() {
    log INFO "Determining installation mode..."

    # Force standalone mode if requested
    if [[ "${ACTVT_FORCE_STANDALONE}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        SELECTED_MODE="standalone"
        log INFO "Installation mode: standalone (forced via ACTVT_FORCE_STANDALONE)"
        return 0
    fi

    # Use explicit mode if provided
    if [ "${ACTVT_INSTALL_MODE}" != "auto" ]; then
        SELECTED_MODE="${ACTVT_INSTALL_MODE}"
        log INFO "Installation mode: ${SELECTED_MODE} (explicitly set)"
        return 0
    fi

    # Auto-detect based on existing web server
    if [ -n "$EXISTING_WEBSERVER" ] && [ "$EXISTING_WEBSERVER" != "unknown" ]; then
        SELECTED_MODE="proxy"
        log INFO "Installation mode: proxy (detected ${EXISTING_WEBSERVER})"
    else
        SELECTED_MODE="standalone"
        log INFO "Installation mode: standalone (no web server detected)"
    fi

    return 0
}

###############################################################################
#                           TLS Certificate Setup                             #
###############################################################################

setup_tls() {
    log STEP "Setting up TLS Certificates"

    # Use required domain from environment
    local domain="${ACTVT_DOMAIN}"
    log INFO "Using domain: ${domain:0:3}***${domain: -4}"

    # Verify DNS resolution
    progress "Verifying DNS resolution..."
    if ! host "${domain}" &> /dev/null; then
        log WARNING "Domain does not resolve. Please ensure DNS is configured correctly."
        log WARNING "Certificate acquisition may fail if DNS is not properly configured."

        # Check environment variable first
        if [ -n "${ACTVT_CONTINUE_WITHOUT_DNS:-}" ]; then
            if [[ "${ACTVT_CONTINUE_WITHOUT_DNS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                log WARNING "Continuing without DNS resolution (ACTVT_CONTINUE_WITHOUT_DNS=yes)"
            else
                error_exit "DNS not configured (ACTVT_CONTINUE_WITHOUT_DNS=${ACTVT_CONTINUE_WITHOUT_DNS})"
            fi
        # In non-interactive mode, fail by default
        elif ! is_interactive; then
            error_exit "DNS not configured (non-interactive mode). Set ACTVT_CONTINUE_WITHOUT_DNS=yes to override"
        # Interactive mode - prompt user
        else
            read -p "Continue anyway? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                error_exit "Please configure DNS and try again"
            fi
        fi
    fi

    # Install Certbot
    progress "Installing Certbot..."
    case "${PKG_MANAGER}" in
        apt-get)
            ${PKG_INSTALL} certbot >> "${ACTVT_LOG_FILE}" 2>&1
            ;;
        yum|dnf)
            # Enable EPEL repository for CentOS/RHEL
            if [ "${OS_NAME}" = "centos" ] || [ "${OS_NAME}" = "rhel" ]; then
                ${PKG_INSTALL} epel-release >> "${ACTVT_LOG_FILE}" 2>&1 || true
            fi
            ${PKG_INSTALL} certbot >> "${ACTVT_LOG_FILE}" 2>&1
            ;;
    esac

    if ! command -v certbot &> /dev/null; then
        error_exit "Failed to install Certbot"
    fi
    progress "Certbot installed successfully"

    # Use required email from environment
    local email="${ACTVT_EMAIL}"

    # Check if certificate already exists
    if [ -d "/etc/letsencrypt/live/${domain}" ]; then
        log INFO "Certificate for domain already exists"

        # Check environment variable first
        local reuse_cert="yes"
        if [ -n "${ACTVT_REUSE_CERT:-}" ]; then
            reuse_cert="${ACTVT_REUSE_CERT}"
        # In non-interactive mode, reuse by default
        elif ! is_interactive; then
            reuse_cert="yes"
        # Interactive mode - prompt user
        else
            read -p "Reuse existing certificate? [Y/n] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                reuse_cert="no"
            fi
        fi

        if [[ "${reuse_cert}" =~ ^[Yy]([Ee][Ss])?$ ]] || [[ "${reuse_cert}" == "yes" ]]; then
            progress "Using existing certificate"
        else
            progress "Obtaining new certificate..."
            certbot certonly --standalone -d "${domain}" \
                --email "${email}" --agree-tos --non-interactive --force-renewal \
                >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to obtain Let's Encrypt certificate"
        fi
    else
        progress "Obtaining Let's Encrypt certificate..."

        # Choose certbot mode based on existing web server
        if [ "$SELECTED_MODE" = "proxy" ] && [ "$EXISTING_WEBSERVER" = "nginx" ]; then
            progress "Using webroot mode (nginx detected)..."

            # Ensure webroot directory exists
            mkdir -p "${ACTVT_NGINX_WEBROOT}/.well-known/acme-challenge"

            # Set proper permissions for webroot
            if id www-data &> /dev/null; then
                chown -R www-data:www-data "${ACTVT_NGINX_WEBROOT}/.well-known" 2>/dev/null || true
            elif id nginx &> /dev/null; then
                chown -R nginx:nginx "${ACTVT_NGINX_WEBROOT}/.well-known" 2>/dev/null || true
            fi

            log INFO "Using webroot: ${ACTVT_NGINX_WEBROOT}"
            log INFO "Ensure nginx is configured to serve .well-known/acme-challenge"

            certbot certonly --webroot -w "${ACTVT_NGINX_WEBROOT}" -d "${domain}" \
                --email "${email}" --agree-tos --non-interactive \
                >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to obtain certificate via webroot. Ensure nginx serves ${ACTVT_NGINX_WEBROOT}/.well-known"

        elif [ "$SELECTED_MODE" = "proxy" ] && [ -n "$EXISTING_WEBSERVER" ]; then
            log WARNING "Detected ${EXISTING_WEBSERVER} on port 80/443"
            log WARNING "To obtain certificates, you have two options:"
            log WARNING "1. Temporarily stop ${EXISTING_WEBSERVER}:"
            log WARNING "   sudo systemctl stop ${EXISTING_WEBSERVER}"
            log WARNING "   Then run this script again"
            log WARNING "   sudo systemctl start ${EXISTING_WEBSERVER}"
            log WARNING ""
            log WARNING "2. Use webroot mode manually:"
            log WARNING "   Set ACTVT_NGINX_WEBROOT to your web server's document root"
            error_exit "Cannot obtain certificate automatically with ${EXISTING_WEBSERVER} running on port 80"

        else
            # Standalone mode (default behavior)
            log INFO "Using standalone mode (requires port 80 to be temporarily accessible)"

            certbot certonly --standalone -d "${domain}" \
                --email "${email}" --agree-tos --non-interactive \
                >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to obtain Let's Encrypt certificate. Ensure port 80 is accessible and not in use."
        fi
    fi

    # Create symlinks to certificates for Vector (auto-update on renewal)
    progress "Installing certificates for Vector..."

    # Create Vector certs directory with secure permissions
    mkdir -p "${VECTOR_CERTS_DIR}"
    chmod 755 "${VECTOR_CERTS_DIR}"

    # Remove old files/symlinks if they exist
    rm -f "${VECTOR_CERTS_DIR}/server.crt" "${VECTOR_CERTS_DIR}/server.key"

    # Create symlinks to live certificates (auto-updates on renewal)
    ln -sf "/etc/letsencrypt/live/${domain}/fullchain.pem" "${VECTOR_CERTS_DIR}/server.crt" || \
        error_exit "Failed to create certificate symlink"
    ln -sf "/etc/letsencrypt/live/${domain}/privkey.pem" "${VECTOR_CERTS_DIR}/server.key" || \
        error_exit "Failed to create private key symlink"

    # Set ownership on symlinks and directory
    chown -h vector:vector "${VECTOR_CERTS_DIR}/server.crt" 2>/dev/null || true
    chown -h vector:vector "${VECTOR_CERTS_DIR}/server.key" 2>/dev/null || true
    chown vector:vector "${VECTOR_CERTS_DIR}"

    progress "Certificates symlinked (will auto-update on renewal)"

    progress "Certificates installed successfully"

    # Set up auto-renewal
    progress "Setting up automatic certificate renewal..."

    # Create renewal hook script
    local renewal_hook="/etc/letsencrypt/renewal-hooks/deploy/actvt-vector.sh"
    mkdir -p "$(dirname ${renewal_hook})"

    cat > "${renewal_hook}" << 'RENEWAL_EOF'
#!/bin/bash
# Certificate renewal hook for Actvt Vector
# Symlinks are used, so certificates auto-update, but we need to restart services

DOMAIN="${RENEWED_LINEAGE##*/}"

# Log renewal event
logger -t actvt-renewal "Certificate renewed for ${DOMAIN}"

# Verify symlinks still exist and point to correct location
if [ ! -L /etc/vector/certs/server.crt ] || [ ! -L /etc/vector/certs/server.key ]; then
    # Recreate symlinks if missing
    rm -f /etc/vector/certs/server.crt /etc/vector/certs/server.key
    ln -sf "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" /etc/vector/certs/server.crt
    ln -sf "/etc/letsencrypt/live/${DOMAIN}/privkey.pem" /etc/vector/certs/server.key
    chown -h vector:vector /etc/vector/certs/server.crt /etc/vector/certs/server.key
    logger -t actvt-renewal "Recreated certificate symlinks"
fi

# Reload or restart Vector service
if systemctl reload vector 2>/dev/null; then
    logger -t actvt-renewal "Vector service reloaded successfully"
    sleep 1
elif systemctl restart vector; then
    # Wait for restart to complete (poll up to 30 seconds)
    wait_count=0
    while ! systemctl is-active --quiet vector && [ $wait_count -lt 30 ]; do
        sleep 1
        wait_count=$((wait_count + 1))
    done

    if systemctl is-active --quiet vector; then
        logger -t actvt-renewal "Vector service restarted successfully"
    else
        logger -t actvt-renewal "ERROR: Vector service failed to start after certificate renewal"
        exit 1
    fi
fi

# If nginx exists, reload it too (for proxy mode)
if systemctl is-active --quiet nginx 2>/dev/null; then
    if systemctl reload nginx; then
        logger -t actvt-renewal "Nginx reloaded successfully"
    else
        logger -t actvt-renewal "WARNING: Failed to reload nginx"
    fi
fi
RENEWAL_EOF

    chmod +x "${renewal_hook}"

    # Test renewal (dry-run)
    if certbot renew --dry-run >> "${ACTVT_LOG_FILE}" 2>&1; then
        progress "Auto-renewal configured successfully"
    else
        log WARNING "Auto-renewal test failed, but certificates are installed"
    fi

    # Store domain for later use
    echo "${domain}" > "${ACTVT_STATE_DIR}/domain"

    log SUCCESS "TLS certificates configured successfully"
}

###############################################################################
#                       Nginx Reverse Proxy Configuration                     #
###############################################################################

configure_nginx_proxy() {
    log STEP "Configuring Nginx Reverse Proxy"

    # Only run in proxy mode with nginx
    if [ "$SELECTED_MODE" != "proxy" ] || [ "$EXISTING_WEBSERVER" != "nginx" ]; then
        log INFO "Skipping nginx configuration (not in proxy mode with nginx)"
        return 0
    fi

    local domain="${ACTVT_DOMAIN}"
    local nginx_config="/etc/nginx/sites-available/actvt-vector"
    local nginx_enabled="/etc/nginx/sites-enabled/actvt-vector"

    progress "Creating nginx configuration for Vector WebSocket..."

    # Backup existing config if it exists
    if [ -f "$nginx_config" ]; then
        backup_file="$(mktemp -p \"${ACTVT_BACKUP_DIR}\" actvt-vector.nginx.backup.XXXXXX)"
        cp "$nginx_config" "$backup_file" || true
        progress "Existing nginx config backed up to $(basename \"$backup_file\")"
    fi

    # Create nginx configuration for Vector proxy
    cat > "$nginx_config" << NGINX_EOF
# Actvt Vector WebSocket Proxy Configuration
# Generated by Actvt installation script

server {
    listen 443 ssl http2;
    server_name ${domain};

    # SSL certificates managed by certbot
    ssl_certificate /etc/letsencrypt/live/${domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${domain}/privkey.pem;

    # SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';

    # Actvt Vector WebSocket endpoint
    location /actvt {
        # Proxy to local Vector WebSocket server
        proxy_pass https://127.0.0.1:${ACTVT_VECTOR_PORT};

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";

        # Proxy headers
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # WebSocket timeouts (24 hours)
        proxy_read_timeout 86400;
        proxy_send_timeout 86400;
        proxy_connect_timeout 60;

        # Disable buffering for WebSocket
        proxy_buffering off;
    }

    # Health check endpoint (optional)
    location /actvt/health {
        access_log off;
        return 200 "OK\n";
        add_header Content-Type text/plain;
    }
}
NGINX_EOF

    progress "Nginx configuration created at $nginx_config"

    # Enable the site
    if [ -d "/etc/nginx/sites-enabled" ]; then
        ln -sf "$nginx_config" "$nginx_enabled"
        progress "Nginx site enabled"
    else
        log WARNING "sites-enabled directory not found. Include $nginx_config in your nginx config manually."
    fi

    # Test nginx configuration
    progress "Testing nginx configuration..."
    if nginx -t >> "${ACTVT_LOG_FILE}" 2>&1; then
        progress "Nginx configuration is valid"

        # Reload nginx
        progress "Reloading nginx..."
        if systemctl reload nginx >> "${ACTVT_LOG_FILE}" 2>&1; then
            progress "Nginx reloaded successfully"
        else
            log WARNING "Failed to reload nginx. You may need to reload it manually."
        fi
    else
        log ERROR "Nginx configuration test failed"
        log ERROR "Please check $nginx_config and fix any errors"
        error_exit "Nginx configuration is invalid"
    fi

    log SUCCESS "Nginx reverse proxy configured successfully"
    log INFO "Vector WebSocket accessible at: wss://${domain}/actvt"
}

###############################################################################
#                          Firewall Configuration                             #
###############################################################################

configure_firewall() {
    log STEP "Configuring Firewall"

    # Check if firewall configuration should be skipped
    local configure_fw="yes"
    if [ -n "${ACTVT_CONFIGURE_FIREWALL:-}" ]; then
        configure_fw="${ACTVT_CONFIGURE_FIREWALL}"
    elif ! is_interactive; then
        configure_fw="yes"
    fi

    if [[ ! "${configure_fw}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        log INFO "Skipping firewall configuration (ACTVT_CONFIGURE_FIREWALL=${configure_fw})"
        log INFO "Please ensure ports 80, 443, and 4096 are accessible"
        return 0
    fi

    # Detect firewall
    local firewall_type=""
    if command -v ufw &> /dev/null; then
        firewall_type="ufw"
    elif command -v firewall-cmd &> /dev/null; then
        firewall_type="firewalld"
    elif command -v iptables &> /dev/null; then
        firewall_type="iptables"
    else
        log WARNING "No firewall detected. Please configure firewall manually."
        log INFO "Required ports: 80 (HTTP), 443 (HTTPS), 4096 (WebSocket)"
        return 0
    fi

    progress "Detected firewall: ${firewall_type}"

    case "${firewall_type}" in
        ufw)
            progress "Configuring UFW..."

            # Enable UFW if not already enabled
            if ! ufw status | grep -q "Status: active"; then
                log WARNING "UFW is not active. Enabling UFW..."
                # Allow SSH first to prevent lockout
                ufw allow 22/tcp >> "${ACTVT_LOG_FILE}" 2>&1
                ufw --force enable >> "${ACTVT_LOG_FILE}" 2>&1
            fi

            # Check which ports are already open
            local port_80_open=false
            local port_443_open=false
            local port_vector_open=false

            if ufw status | grep -qE "^80/tcp.*ALLOW"; then
                port_80_open=true
            fi
            if ufw status | grep -qE "^443/tcp.*ALLOW"; then
                port_443_open=true
            fi
            if ufw status | grep -qE "^${ACTVT_VECTOR_PORT}/tcp.*ALLOW"; then
                port_vector_open=true
            fi

            # In proxy mode, ports 80/443 are likely already open
            if [ "$SELECTED_MODE" = "proxy" ]; then
                if [ "$port_80_open" = true ] && [ "$port_443_open" = true ]; then
                    progress "Ports 80 and 443 already open (existing web server)"
                else
                    [ "$port_80_open" = false ] && ufw allow 80/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 80"
                    [ "$port_443_open" = false ] && ufw allow 443/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 443"
                fi
                # In proxy mode, Vector port doesn't need to be exposed
                progress "Skipping port ${ACTVT_VECTOR_PORT} (proxy mode - localhost only)"
            else
                # Standalone mode - open all ports
                [ "$port_80_open" = false ] && ufw allow 80/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 80"
                [ "$port_443_open" = false ] && ufw allow 443/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 443"
                [ "$port_vector_open" = false ] && ufw allow ${ACTVT_VECTOR_PORT}/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port ${ACTVT_VECTOR_PORT}"
            fi

            progress "Firewall rules configured"
            ;;

        firewalld)
            progress "Configuring firewalld..."

            # Start firewalld if not running
            if ! systemctl is-active --quiet firewalld; then
                systemctl start firewalld
            fi

            # Check which ports are already open
            local port_80_open=false
            local port_443_open=false
            local port_vector_open=false

            if firewall-cmd --list-ports 2>/dev/null | grep -q "80/tcp"; then
                port_80_open=true
            fi
            if firewall-cmd --list-ports 2>/dev/null | grep -q "443/tcp"; then
                port_443_open=true
            fi
            if firewall-cmd --list-ports 2>/dev/null | grep -q "${ACTVT_VECTOR_PORT}/tcp"; then
                port_vector_open=true
            fi

            # In proxy mode, ports 80/443 are likely already open
            if [ "$SELECTED_MODE" = "proxy" ]; then
                if [ "$port_80_open" = true ] && [ "$port_443_open" = true ]; then
                    progress "Ports 80 and 443 already open (existing web server)"
                else
                    [ "$port_80_open" = false ] && firewall-cmd --permanent --add-port=80/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 80"
                    [ "$port_443_open" = false ] && firewall-cmd --permanent --add-port=443/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 443"
                fi
                # In proxy mode, Vector port doesn't need to be exposed
                progress "Skipping port ${ACTVT_VECTOR_PORT} (proxy mode - localhost only)"
            else
                # Standalone mode - open all ports
                [ "$port_80_open" = false ] && firewall-cmd --permanent --add-port=80/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 80"
                [ "$port_443_open" = false ] && firewall-cmd --permanent --add-port=443/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 443"
                [ "$port_vector_open" = false ] && firewall-cmd --permanent --add-port=${ACTVT_VECTOR_PORT}/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port ${ACTVT_VECTOR_PORT}"
            fi

            firewall-cmd --reload >> "${ACTVT_LOG_FILE}" 2>&1
            progress "Firewall rules configured"
            ;;

        iptables)
            progress "Configuring iptables..."

            # In proxy mode, ports 80/443 are likely already open
            if [ "$SELECTED_MODE" = "proxy" ]; then
                # Check if rules already exist before adding
                if ! iptables -C INPUT -p tcp --dport 80 -j ACCEPT 2>/dev/null; then
                    iptables -I INPUT -p tcp --dport 80 -j ACCEPT
                    progress "Opened port 80"
                else
                    progress "Port 80 already open"
                fi

                if ! iptables -C INPUT -p tcp --dport 443 -j ACCEPT 2>/dev/null; then
                    iptables -I INPUT -p tcp --dport 443 -j ACCEPT
                    progress "Opened port 443"
                else
                    progress "Port 443 already open"
                fi

                # In proxy mode, Vector port doesn't need to be exposed
                progress "Skipping port ${ACTVT_VECTOR_PORT} (proxy mode - localhost only)"
            else
                # Standalone mode - add all rules if they don't exist
                iptables -C INPUT -p tcp --dport 80 -j ACCEPT 2>/dev/null || \
                    iptables -I INPUT -p tcp --dport 80 -j ACCEPT
                iptables -C INPUT -p tcp --dport 443 -j ACCEPT 2>/dev/null || \
                    iptables -I INPUT -p tcp --dport 443 -j ACCEPT
                iptables -C INPUT -p tcp --dport ${ACTVT_VECTOR_PORT} -j ACCEPT 2>/dev/null || \
                    iptables -I INPUT -p tcp --dport ${ACTVT_VECTOR_PORT} -j ACCEPT
            fi

            # Try to save rules
            if command -v iptables-save &> /dev/null; then
                mkdir -p /etc/iptables 2>/dev/null || true
                iptables-save > /etc/iptables/rules.v4 2>/dev/null || \
                    log WARNING "Could not persist iptables rules. They may not survive reboot."
            fi

            progress "Firewall rules configured"
            ;;
    esac

    log SUCCESS "Firewall configuration complete"
}

###############################################################################
#                          Service Management                                 #
###############################################################################

start_vector_service() {
    log STEP "Starting Vector Service"

    # Stop Vector if running (to clear any demo/default config)
    if systemctl is-active --quiet vector; then
        progress "Stopping existing Vector service..."
        systemctl stop vector >> "${ACTVT_LOG_FILE}" 2>&1 || true

        # Wait for service to fully stop (poll up to 30 seconds)
        local wait_count=0
        while systemctl is-active --quiet vector && [ $wait_count -lt 30 ]; do
            sleep 1
            wait_count=$((wait_count + 1))
        done

        if systemctl is-active --quiet vector; then
            log WARNING "Service did not stop cleanly, forcing stop..."
            systemctl kill vector >> "${ACTVT_LOG_FILE}" 2>&1 || true
            sleep 2
        else
            progress "Service stopped successfully"
        fi
    fi

    # Create systemd override to explicitly use our config file
    progress "Configuring Vector service to use /etc/vector/vector.toml..."
    mkdir -p /etc/systemd/system/vector.service.d
    cat > /etc/systemd/system/vector.service.d/override.conf << 'OVERRIDE_EOF'
[Service]
ExecStart=
ExecStart=/usr/bin/vector --config /etc/vector/vector.toml
OVERRIDE_EOF

    # Reload systemd daemon to pick up changes
    progress "Reloading systemd daemon..."
    systemctl daemon-reload >> "${ACTVT_LOG_FILE}" 2>&1

    # Enable systemd service
    progress "Enabling Vector service..."
    systemctl enable vector >> "${ACTVT_LOG_FILE}" 2>&1

    # Start service
    progress "Starting Vector with custom configuration..."
    if systemctl start vector >> "${ACTVT_LOG_FILE}" 2>&1; then
        progress "Vector service start command issued"
    else
        log ERROR "Failed to start Vector service"
        log INFO "Checking service status..."
        systemctl status vector --no-pager >> "${ACTVT_LOG_FILE}" 2>&1 || true
        error_exit "Vector service failed to start. Check logs: journalctl -u vector -n 50"
    fi

    # Wait for service to become active (poll up to 30 seconds)
    progress "Waiting for Vector service to become active..."
    local wait_count=0
    while ! systemctl is-active --quiet vector && [ $wait_count -lt 30 ]; do
        sleep 1
        wait_count=$((wait_count + 1))
    done

    # Verify service is running
    if ! systemctl is-active --quiet vector; then
        log ERROR "Vector service did not start within 30 seconds"
        systemctl status vector --no-pager >> "${ACTVT_LOG_FILE}" 2>&1 || true
        error_exit "Vector service is not running"
    fi

    progress "Vector service is active"

    # Give service a moment to fully initialize before checking logs
    sleep 2

    # Verify it's not running demo configuration
    if journalctl -u vector -n 20 --no-pager 2>/dev/null | grep -q "BronzeGamer\|meln1ks\|We're gonna need a bigger boat"; then
        log WARNING "Vector appears to be running with demo configuration, attempting restart..."
        systemctl restart vector >> "${ACTVT_LOG_FILE}" 2>&1 || true

        # Wait for restart to complete (poll up to 30 seconds)
        wait_count=0
        while ! systemctl is-active --quiet vector && [ $wait_count -lt 30 ]; do
            sleep 1
            wait_count=$((wait_count + 1))
        done

        if ! systemctl is-active --quiet vector; then
            error_exit "Vector service failed to restart"
        fi

        progress "Vector service restarted successfully"
    fi

    log SUCCESS "Vector service started and enabled"
}

###############################################################################
#                          Validation & Testing                               #
###############################################################################

validate_installation() {
    log STEP "Validating Installation"

    # Check Vector is running
    progress "Checking Vector service..."
    if systemctl is-active --quiet vector; then
        progress "Vector service: Running ✓"
    else
        log ERROR "Vector service is not running"
        return 1
    fi

    # Check port 4096 is listening
    progress "Checking WebSocket port..."
    if netstat -tuln 2>/dev/null | grep -q ":4096 " || \
       ss -tuln 2>/dev/null | grep -q ":4096 "; then
        progress "Port 4096: Listening ✓"
    else
        log WARNING "Port 4096 is not listening yet (may take a moment)"
    fi

    # Check TLS certificates exist and are valid
    progress "Checking TLS certificates..."
    if [ -f "${VECTOR_CERTS_DIR}/server.crt" ] && [ -f "${VECTOR_CERTS_DIR}/server.key" ]; then
        local cert_expiry=$(openssl x509 -in "${VECTOR_CERTS_DIR}/server.crt" -noout -enddate 2>/dev/null | cut -d= -f2)
        progress "TLS certificates: Valid until ${cert_expiry} ✓"
    else
        log ERROR "TLS certificates not found"
        return 1
    fi

    # Get domain from state file
    local domain=""
    if [ -f "${ACTVT_STATE_DIR}/domain" ]; then
        domain=$(cat "${ACTVT_STATE_DIR}/domain")
    fi

    log SUCCESS "Installation validation complete"

    # Display connection information
    echo
    echo -e "${GREEN}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}${BOLD}  Installation Complete!${NC}"
    echo -e "${GREEN}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
    echo -e "${BOLD}Installation Mode:${NC} ${SELECTED_MODE}"
    echo
    echo -e "${BOLD}WebSocket URL:${NC}"
    if [ -n "${domain}" ]; then
        if [ "$SELECTED_MODE" = "proxy" ]; then
            echo -e "  ${CYAN}wss://${domain}/actvt${NC}"
            echo -e "  ${BOLD}(via nginx reverse proxy)${NC}"
        else
            echo -e "  ${CYAN}wss://${domain}:${ACTVT_VECTOR_PORT}${NC}"
            echo -e "  ${BOLD}(direct connection)${NC}"
        fi
    else
        if [ "$SELECTED_MODE" = "proxy" ]; then
            echo -e "  ${CYAN}wss://YOUR_DOMAIN/actvt${NC}"
        else
            echo -e "  ${CYAN}wss://YOUR_DOMAIN:${ACTVT_VECTOR_PORT}${NC}"
        fi
    fi
    echo
    echo -e "${BOLD}Next Steps:${NC}"
    echo -e "  1. Open Actvt on your Mac"
    echo -e "  2. Go to Settings → Remote Servers"
    echo -e "  3. Add a new server with the WebSocket URL above"
    echo -e "  4. Start monitoring your remote server!"
    echo
    echo -e "${BOLD}Service Management:${NC}"
    echo -e "  • Check status:  ${CYAN}sudo systemctl status vector${NC}"
    echo -e "  • View logs:     ${CYAN}sudo journalctl -u vector -f${NC}"
    echo -e "  • Restart:       ${CYAN}sudo systemctl restart vector${NC}"
    echo
    echo -e "${BOLD}Documentation:${NC}"
    echo -e "  ${CYAN}https://actvt.io/docs/remote-server/overview${NC}"
    echo
    echo -e "${GREEN}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
}

###############################################################################
#                              Main Execution                                 #
###############################################################################

main() {
    # Clear screen and show banner
    clear
    echo -e "${CYAN}${BOLD}"
    echo "╔═══════════════════════════════════════════════════════════════╗"
    echo "║                                                               ║"
    echo "║           Actvt Remote Server Installation Script            ║"
    echo "║                      Version ${SCRIPT_VERSION}                        ║"
    echo "║                                                               ║"
    echo "╚═══════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    echo

    # Validate and create state directories
    # Validate state directory path to prevent path traversal
    if [[ ! "${ACTVT_STATE_DIR}" =~ ^/var/lib/actvt$ ]]; then
        echo "ERROR: Invalid state directory path: ${ACTVT_STATE_DIR}" >&2
        exit 1
    fi

    # Validate backup directory path to prevent path traversal
    if [[ ! "${ACTVT_BACKUP_DIR}" =~ ^/var/lib/actvt/backups$ ]]; then
        echo "ERROR: Invalid backup directory path: ${ACTVT_BACKUP_DIR}" >&2
        exit 1
    fi

    # Create directories with restrictive permissions
    mkdir -p "${ACTVT_STATE_DIR}"
    chmod 700 "${ACTVT_STATE_DIR}"
    mkdir -p "${ACTVT_BACKUP_DIR}"
    chmod 700 "${ACTVT_BACKUP_DIR}"

    # Initialize log file
    touch "${ACTVT_LOG_FILE}" 2>/dev/null || ACTVT_LOG_FILE="/tmp/actvt-install.log"
    chmod 600 "${ACTVT_LOG_FILE}"

    log INFO "Starting Actvt installation (version ${SCRIPT_VERSION})"
    log INFO "Log file: ${ACTVT_LOG_FILE}"

    # Run installation steps
    detect_os
    check_requirements
    detect_existing_webserver
    determine_installation_mode
    install_vector
    configure_vector
    setup_tls
    configure_nginx_proxy
    configure_firewall
    start_vector_service
    validate_installation

    # Save installation state
    echo "version=${SCRIPT_VERSION}" > "${ACTVT_STATE_DIR}/install.state"
    echo "installed_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "${ACTVT_STATE_DIR}/install.state"
    echo "mode=${SELECTED_MODE}" >> "${ACTVT_STATE_DIR}/install.state"
    echo "webserver=${EXISTING_WEBSERVER:-none}" >> "${ACTVT_STATE_DIR}/install.state"

    log INFO "Installation completed successfully"
}

# Run main function
main "$@"
