#!/usr/bin/env bash
###############################################################################
#                    Actvt Remote Server Installation Script                  #
###############################################################################
#
# Description: Automated installation script for Actvt remote server monitoring
#
# Required environment variables:
#   ACTVT_DOMAIN - Your server domain name (e.g., monitor.yourdomain.com)
#   ACTVT_EMAIL  - Email address for Let's Encrypt notifications
#
# Optional environment variables:
#   ACTVT_INSTALL_MODE       - Installation mode: auto|standalone|proxy (default: auto)
#   ACTVT_VECTOR_PORT        - Port for Vector WebSocket server (default: 4096)
#   ACTVT_NGINX_WEBROOT      - Nginx webroot for certificate validation (default: /var/www/html)
#   ACTVT_FORCE_STANDALONE   - Force standalone mode even if web server detected (default: no)
#   ACTVT_CONFIGURE_FIREWALL - Configure firewall rules (default: yes)
#   ACTVT_ENABLE_MTLS        - Enable mTLS client certificate verification (default: no)
#   ACTVT_MTLS_CA_DAYS       - CA certificate validity in days (default: 3650)
#   ACTVT_MTLS_CLIENT_DAYS   - Client certificate validity in days (default: 365)
#   ACTVT_MTLS_CLIENT_CN     - Client certificate common name (default: actvt-client-001)
#
# Installation Modes:
#   - auto: Automatically detect existing web server and choose appropriate mode
#   - standalone: Fresh server installation (Vector exposed on port 4096)
#   - proxy: Install behind existing nginx (Vector on localhost, nginx proxies /actvt path)
#
# Usage (basic):
#   export ACTVT_DOMAIN=monitor.yourdomain.com
#   export ACTVT_EMAIL=admin@yourdomain.com
#   curl -L https://actvt.io/install | bash
#
# Usage (with nginx reverse proxy):
#   export ACTVT_DOMAIN=monitor.yourdomain.com
#   export ACTVT_EMAIL=admin@yourdomain.com
#   export ACTVT_INSTALL_MODE=proxy
#   curl -L https://actvt.io/install | bash
#
# Usage (enable mTLS for enhanced security):
#   export ACTVT_DOMAIN=monitor.yourdomain.com
#   export ACTVT_EMAIL=admin@yourdomain.com
#   export ACTVT_ENABLE_MTLS=yes
#   curl -L https://actvt.io/install | bash
#
# Documentation: https://actvt.io/docs/remote-server/overview
#
# Version: 1.0.0
# Last Updated: 2025-10-08
#
###############################################################################

set -euo pipefail

# Script version
readonly SCRIPT_VERSION="1.0.0"

# Installation mode configuration
# ACTVT_INSTALL_MODE:
#   - "auto" (default): Detect and choose appropriate mode
#   - "standalone": Dedicated server, ports 80/443/4096 exposed directly
#   - "proxy": Behind existing nginx, localhost-only binding
readonly ACTVT_INSTALL_MODE="${ACTVT_INSTALL_MODE:-auto}"
readonly ACTVT_VECTOR_PORT="${ACTVT_VECTOR_PORT:-4096}"
readonly ACTVT_NGINX_WEBROOT="${ACTVT_NGINX_WEBROOT:-/var/www/html}"
readonly ACTVT_FORCE_STANDALONE="${ACTVT_FORCE_STANDALONE:-no}"
readonly ACTVT_ENABLE_MTLS="${ACTVT_ENABLE_MTLS:-no}"
readonly ACTVT_MTLS_CA_DAYS="${ACTVT_MTLS_CA_DAYS:-3650}"
readonly ACTVT_MTLS_CLIENT_DAYS="${ACTVT_MTLS_CLIENT_DAYS:-365}"
readonly ACTVT_MTLS_CLIENT_CN="${ACTVT_MTLS_CLIENT_CN:-actvt-client-001}"

# Global variables for detected state
EXISTING_WEBSERVER=""
SELECTED_MODE=""

# Installation directories
readonly ACTVT_STATE_DIR="/var/lib/actvt"
readonly ACTVT_LOG_FILE="/var/log/actvt-install.log"
readonly ACTVT_BACKUP_DIR="${ACTVT_STATE_DIR}/backups"
readonly VECTOR_CONFIG_DIR="/etc/vector"
readonly VECTOR_CERTS_DIR="${VECTOR_CONFIG_DIR}/certs"
readonly VECTOR_MTLS_DIR="${VECTOR_CERTS_DIR}/mtls"
readonly VECTOR_MTLS_CLIENTS_DIR="${VECTOR_MTLS_DIR}/clients"

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color
readonly BOLD='\033[1m'

# Progress tracking
CURRENT_STEP=0
TOTAL_STEPS=10

###############################################################################
#                           Logging Functions                                 #
###############################################################################

log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Log to file
    echo "[${timestamp}] [${level}] ${message}" >> "${ACTVT_LOG_FILE}" 2>/dev/null || true

    # Log to console with colors
    case "${level}" in
        INFO)
            echo -e "${BLUE}ℹ${NC} ${message}"
            ;;
        SUCCESS)
            echo -e "${GREEN}✓${NC} ${message}"
            ;;
        WARNING)
            echo -e "${YELLOW}⚠${NC} ${message}"
            ;;
        ERROR)
            echo -e "${RED}✗${NC} ${message}"
            ;;
        STEP)
            CURRENT_STEP=$((CURRENT_STEP + 1))
            echo -e "\n${CYAN}${BOLD}[${CURRENT_STEP}/${TOTAL_STEPS}]${NC} ${BOLD}${message}${NC}"
            ;;
    esac
}

progress() {
    echo -e "${CYAN}  →${NC} $*"
}

###############################################################################
#                           Error Handling                                    #
###############################################################################

cleanup() {
    local exit_code=$?
    if [ ${exit_code} -ne 0 ]; then
        log ERROR "Installation failed with exit code ${exit_code}"
        log ERROR "Check the log file at ${ACTVT_LOG_FILE} for details"
        log INFO "You can try running the script again or follow the manual installation guide"
        log INFO "Documentation: https://actvt.io/docs/remote-server/overview"
    fi
}

trap cleanup EXIT

error_exit() {
    log ERROR "$1"
    exit 1
}

###############################################################################
#                        Interactive Mode Detection                           #
###############################################################################

is_interactive() {
    # Check if explicitly set to non-interactive
    if [ "${ACTVT_NON_INTERACTIVE:-}" = "yes" ]; then
        return 1
    fi
    # Check if stdin is a terminal
    [ -t 0 ]
}

###############################################################################
#                           OS Detection                                      #
###############################################################################

detect_os() {
    log STEP "Detecting Operating System"

    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS_NAME="${ID}"
        OS_VERSION="${VERSION_ID}"
        OS_PRETTY_NAME="${PRETTY_NAME}"
    elif [ -f /etc/lsb-release ]; then
        . /etc/lsb-release
        OS_NAME="${DISTRIB_ID,,}"
        OS_VERSION="${DISTRIB_RELEASE}"
        OS_PRETTY_NAME="${DISTRIB_DESCRIPTION}"
    elif [ -f /etc/redhat-release ]; then
        OS_NAME="rhel"
        OS_VERSION=$(cat /etc/redhat-release | grep -oP '\d+\.\d+' | head -1)
        OS_PRETTY_NAME=$(cat /etc/redhat-release)
    else
        error_exit "Unsupported operating system. Supported: Ubuntu, Debian, CentOS, RHEL, Amazon Linux"
    fi

    progress "Detected: ${OS_PRETTY_NAME}"

    # Determine package manager
    case "${OS_NAME}" in
        ubuntu|debian)
            PKG_MANAGER="apt-get"
            PKG_UPDATE="apt-get update"
            PKG_INSTALL="apt-get install -y"
            ;;
        centos|rhel)
            if command -v dnf &> /dev/null; then
                PKG_MANAGER="dnf"
                PKG_UPDATE="dnf check-update || true"
                PKG_INSTALL="dnf install -y"
            else
                PKG_MANAGER="yum"
                PKG_UPDATE="yum check-update || true"
                PKG_INSTALL="yum install -y"
            fi
            ;;
        amzn|amazonlinux)
            PKG_MANAGER="yum"
            PKG_UPDATE="yum check-update || true"
            PKG_INSTALL="yum install -y"
            ;;
        *)
            error_exit "Unsupported distribution: ${OS_NAME}"
            ;;
    esac

    progress "Package manager: ${PKG_MANAGER}"
    log SUCCESS "OS detection complete"
}

###############################################################################
#                        System Requirements Check                            #
###############################################################################

check_requirements() {
    log STEP "Checking System Requirements"

    # Check if running as root or with sudo
    if [ "$EUID" -ne 0 ]; then
        error_exit "This script must be run as root or with sudo"
    fi

    # Check required environment variables
    if [ -z "${ACTVT_DOMAIN:-}" ]; then
        error_exit "ACTVT_DOMAIN environment variable is required. Example: export ACTVT_DOMAIN=monitor.yourdomain.com"
    fi

    if [ -z "${ACTVT_EMAIL:-}" ]; then
        error_exit "ACTVT_EMAIL environment variable is required. Example: export ACTVT_EMAIL=admin@yourdomain.com"
    fi

    # Validate domain format (RFC 1123 compliant)
    if ! [[ "${ACTVT_DOMAIN}" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
        error_exit "Invalid domain format. Must be a valid hostname (e.g., monitor.example.com)"
    fi

    # Validate email format (RFC 5322 basic)
    if ! [[ "${ACTVT_EMAIL}" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        error_exit "Invalid email format. Must be a valid email address"
    fi

    # Redact sensitive information in logs (show partial for verification)
    progress "Domain: ${ACTVT_DOMAIN:0:3}***${ACTVT_DOMAIN: -4}"
    progress "Email: ${ACTVT_EMAIL%%@*}@***"

    # DNS Configuration Warning
    log WARNING "IMPORTANT: DNS Configuration Required"
    log WARNING "Your domain must have an A or CNAME record pointing to this server"
    log WARNING "pointing to this server's IP address for Let's Encrypt to work."
    log WARNING "Without proper DNS configuration, certificate acquisition will fail."

    # Check available disk space (need at least 100MB)
    local available_space=$(df /tmp | tail -1 | awk '{print $4}')
    if [ "${available_space}" -lt 102400 ]; then
        error_exit "Insufficient disk space. Need at least 100MB free"
    fi
    progress "Disk space: OK ($(numfmt --to=iec-i --suffix=B $((available_space * 1024))))"

    # Check available memory (need at least 512MB)
    local available_mem=$(free -m | awk '/^Mem:/{print $2}')
    if [ "${available_mem}" -lt 512 ]; then
        log WARNING "Low memory detected (${available_mem}MB). Recommended: 1GB+"
    else
        progress "Memory: OK (${available_mem}MB)"
    fi

    # Check internet connectivity
    if ! ping -c 1 -W 2 8.8.8.8 &> /dev/null; then
        error_exit "No internet connectivity detected"
    fi

    # Check if required commands are available
    for cmd in curl tar; do
        if ! command -v ${cmd} &> /dev/null; then
            progress "Installing ${cmd}..."
            ${PKG_INSTALL} ${cmd} >> "${ACTVT_LOG_FILE}" 2>&1
        fi
    done

    log SUCCESS "All system requirements met"
}

###############################################################################
#                           Vector Installation                               #
###############################################################################

install_vector() {
    log STEP "Installing Vector"

    # Check if Vector is already installed
    if command -v vector &> /dev/null; then
        local installed_version=$(vector --version | grep -oP 'vector \K[0-9.]+' || echo "unknown")
        log INFO "Vector is already installed (version ${installed_version})"

        # Check environment variable first
        if [ -n "${ACTVT_REINSTALL_VECTOR:-}" ]; then
            if [[ "${ACTVT_REINSTALL_VECTOR}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                progress "Reinstalling Vector (ACTVT_REINSTALL_VECTOR=yes)"
            else
                log INFO "Skipping Vector installation (ACTVT_REINSTALL_VECTOR=${ACTVT_REINSTALL_VECTOR})"
                return 0
            fi
        # In non-interactive mode, skip by default
        elif ! is_interactive; then
            log INFO "Skipping Vector installation (non-interactive mode)"
            return 0
        # Interactive mode - prompt user
        else
            read -p "Do you want to reinstall/update Vector? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log INFO "Skipping Vector installation"
                return 0
            fi
        fi
    fi

    # Vector version to install
    readonly VECTOR_VERSION="0.50.0-1"

    progress "Adding Vector repository..."

    case "${PKG_MANAGER}" in
        apt-get)
            # Install required packages for repository management
            progress "Installing repository dependencies..."
            ${PKG_INSTALL} apt-transport-https gnupg ca-certificates curl >> "${ACTVT_LOG_FILE}" 2>&1

            # Add Datadog GPG keys for package verification
            progress "Adding Vector GPG keys..."
            curl -fsSL https://keys.datadoghq.com/DATADOG_APT_KEY_CURRENT.public 2>> "${ACTVT_LOG_FILE}" | \
                gpg --dearmor -o /usr/share/keyrings/datadog-archive-keyring.gpg 2>> "${ACTVT_LOG_FILE}" || \
                error_exit "Failed to add Vector GPG keys"

            # Add Vector repository
            progress "Configuring Vector repository..."
            echo "deb [signed-by=/usr/share/keyrings/datadog-archive-keyring.gpg] https://apt.vector.dev/ stable vector-0" | \
                tee /etc/apt/sources.list.d/vector.list > /dev/null || \
                error_exit "Failed to add Vector repository"

            # Update package list
            progress "Updating package list..."
            ${PKG_UPDATE} >> "${ACTVT_LOG_FILE}" 2>&1

            # Install specific Vector version
            progress "Installing Vector ${VECTOR_VERSION}..."
            ${PKG_INSTALL} vector=${VECTOR_VERSION} >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to install Vector"
            ;;

        yum|dnf)
            # Add Datadog GPG keys
            progress "Adding Vector GPG keys..."
            rpm --import https://keys.datadoghq.com/DATADOG_RPM_KEY_CURRENT.public >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to import Vector GPG keys"

            # Add Vector repository
            progress "Configuring Vector repository..."
            cat > /etc/yum.repos.d/vector.repo << 'EOF'
[vector]
name=Vector
baseurl=https://yum.vector.dev/stable/vector-0/$basearch/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://keys.datadoghq.com/DATADOG_RPM_KEY_CURRENT.public
       https://keys.datadoghq.com/DATADOG_RPM_KEY_B01082D3.public
       https://keys.datadoghq.com/DATADOG_RPM_KEY_FD4BF915.public
EOF

            if [ $? -ne 0 ]; then
                error_exit "Failed to add Vector repository"
            fi

            # Install specific Vector version
            progress "Installing Vector ${VECTOR_VERSION}..."
            ${PKG_INSTALL} vector-${VECTOR_VERSION} >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to install Vector"
            ;;
    esac

    # Verify installation
    if ! command -v vector &> /dev/null; then
        error_exit "Vector installation failed"
    fi

    local vector_version=$(vector --version | grep -oP 'vector \K[0-9.]+' || echo "unknown")
    progress "Vector ${vector_version} installed successfully"

    # Verify systemd service
    if ! systemctl list-unit-files | grep -q vector.service; then
        log WARNING "Vector systemd service not found"
    fi

    # Verify vector user was created
    if ! id vector &> /dev/null; then
        log WARNING "Vector user not found, creating manually..."
        useradd -r -s /bin/false vector || true
    fi

    log SUCCESS "Vector installation complete"
}

###############################################################################
#                          Vector Configuration                               #
###############################################################################

configure_vector() {
    log STEP "Configuring Vector"

    # Detect GPU (inline check)
    local gpu_enabled="false"
    local gpu_detected=false
    if command -v nvidia-smi &> /dev/null && nvidia-smi &> /dev/null; then
        local gpu_name=$(nvidia-smi --query-gpu=name --format=csv,noheader | head -1)
        log INFO "NVIDIA GPU detected: ${gpu_name}"
        gpu_detected=true
    fi

    if [ "$gpu_detected" = true ]; then
        # Check environment variable first
        if [ -n "${ACTVT_ENABLE_GPU:-}" ]; then
            if [[ "${ACTVT_ENABLE_GPU}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                gpu_enabled="true"
                progress "GPU monitoring enabled (ACTVT_ENABLE_GPU=yes)"
            else
                progress "GPU monitoring disabled (ACTVT_ENABLE_GPU=${ACTVT_ENABLE_GPU})"
            fi
        # In non-interactive mode, enable by default if GPU detected
        elif ! is_interactive; then
            gpu_enabled="true"
            progress "GPU monitoring enabled (non-interactive mode, GPU detected)"
        # Interactive mode - prompt user
        else
            read -p "Enable GPU monitoring? [Y/n] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                gpu_enabled="true"
                progress "GPU monitoring will be enabled"
            fi
        fi
    fi

    # Backup existing configuration if it exists
    if [ -f "${VECTOR_CONFIG_DIR}/vector.toml" ]; then
        # Create backup with secure temporary filename (using mktemp for security)
        backup_file="$(mktemp -p "${ACTVT_BACKUP_DIR}" vector.toml.backup.XXXXXX)"
        if [ $? -ne 0 ]; then
            error_exit "Failed to create backup file"
        fi

        # Copy configuration to backup
        cp "${VECTOR_CONFIG_DIR}/vector.toml" "$backup_file" || \
            error_exit "Failed to backup existing configuration"

        progress "Existing configuration backed up to $(basename "$backup_file")"
    fi

    # Create Vector configuration directory
    mkdir -p "${VECTOR_CONFIG_DIR}"
    chmod 755 "${VECTOR_CONFIG_DIR}"

    progress "Creating Vector configuration..."

    # Generate vector.toml
    cat > "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
###############################################################################
#                    vector.toml Production Configuration                     #
###############################################################################

################################ 1. SOURCES ###################################

# Real-time system metrics
[sources.system_metrics]
type                 = "host_metrics"
collectors           = ["cpu", "memory", "disk", "filesystem", "network", "host", "load"]
scrape_interval_secs = 1

# System information (static details collected less frequently)
[sources.system_info]
type    = "exec"
command = [
  "sh", "-c",
  "echo \"{\\\"os\\\":\\\"$(grep PRETTY_NAME /etc/os-release | cut -d'=' -f2 | tr -d '\\\"')\\\",\\\"arch\\\":\\\"$(uname -m)\\\",\\\"domain\\\":\\\"$(cat /var/lib/actvt/domain 2>/dev/null || echo 'unknown')\\\",\\\"ipv4\\\":\\\"$(ip route get 1 2>/dev/null | awk '{print $$7;exit}' || hostname -I 2>/dev/null | awk '{print $$1}' || echo 'unknown')\\\"}\""
]
mode = "scheduled"

[sources.system_info.scheduled]
exec_interval_secs = 300

EOF

    # Add GPU configuration if enabled
    if [ "${gpu_enabled}" = "true" ]; then
        cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
# GPU metrics (requires nvidia-smi)
[sources.gpu_metrics]
type    = "exec"
command = [
  "nvidia-smi",
  "--query-gpu=utilization.gpu,memory.used,memory.total,gpu_name,temperature.gpu,power.draw,power.limit,fan.speed,clocks.current.graphics,clocks.current.memory,utilization.encoder,utilization.decoder,pstate",
  "--format=csv,noheader,nounits"
]
mode = "scheduled"

[sources.gpu_metrics.scheduled]
exec_interval_secs = 1

EOF
    fi

    # Add transforms and sinks
    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
################################# 2. NORMALISE ################################

[transforms.metrics_to_logs]
type   = "metric_to_log"
inputs = ["system_metrics"]

# System information transform
[transforms.format_system_info]
type   = "remap"
inputs = ["system_info"]
source = '''
parsed = parse_json!(.message)
.metric_type = "system_info"
.os          = parsed.os
.arch        = parsed.arch
.domain      = parsed.domain
.ipv4        = parsed.ipv4
.host        = get_env_var("HOSTNAME") ?? "unknown-host"
.timestamp   = format_timestamp!(now(), format: "%+")
'''

EOF

    if [ "${gpu_enabled}" = "true" ]; then
        cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
# GPU metrics transform (parses CSV: utilization,memory.used,memory.total,gpu_name)
[transforms.format_gpu]
type   = "remap"
inputs = ["gpu_metrics"]
source = '''
parts = split!(.message, ",")
gpu_utilization = to_float!(parts[0])
memory_used_mb = to_float!(parts[1])
memory_total_mb = to_float!(parts[2])
gpu_name = strip_whitespace!(parts[3])

# GPU utilization metric
.metric_type = "gpu_utilization"
.value       = gpu_utilization
.gpu_name    = gpu_name
.host        = get_env_var("HOSTNAME") ?? "unknown-host"
.timestamp   = format_timestamp!(now(), format: "%+")
'''

[transforms.format_gpu_memory]
type   = "remap"
inputs = ["gpu_metrics"]
source = '''
parts = split!(.message, ",")
memory_used_mb = to_float!(parts[1])
memory_total_mb = to_float!(parts[2])
gpu_name = strip_whitespace!(parts[3])

# GPU memory metric
.metric_type = "gpu_memory"
.memory_used = memory_used_mb
.memory_total = memory_total_mb
.memory_percent = if memory_total_mb > 0 { ((memory_used_mb / memory_total_mb) ?? 0.0) * 100.0 } else { 0.0 }
.gpu_name    = gpu_name
.host        = get_env_var("HOSTNAME") ?? "unknown-host"
.timestamp   = format_timestamp!(now(), format: "%+")
'''

# GPU temperature transform
[transforms.format_gpu_temperature]
type   = "remap"
inputs = ["gpu_metrics"]
source = '''
parts = split!(.message, ",")
temperature_celsius = to_float!(parts[4])
gpu_name = strip_whitespace!(parts[3])

# GPU temperature metric
.metric_type = "gpu_temperature"
.value       = temperature_celsius
.gpu_name    = gpu_name
.host        = get_env_var("HOSTNAME") ?? "unknown-host"
.timestamp   = format_timestamp!(now(), format: "%+")
'''

# GPU clock frequency transform
[transforms.format_gpu_clocks]
type   = "remap"
inputs = ["gpu_metrics"]
source = '''
parts = split!(.message, ",")
clock_graphics_mhz = to_float!(parts[8])
clock_memory_mhz = to_float!(parts[9])
gpu_name = strip_whitespace!(parts[3])

# GPU clocks metric
.metric_type = "gpu_clocks"
.clock_graphics = clock_graphics_mhz
.clock_memory = clock_memory_mhz
.gpu_name    = gpu_name
.host        = get_env_var("HOSTNAME") ?? "unknown-host"
.timestamp   = format_timestamp!(now(), format: "%+")
'''

# GPU power metrics transform
[transforms.format_gpu_power]
type   = "remap"
inputs = ["gpu_metrics"]
source = '''
parts = split!(.message, ",")
power_draw_watts = to_float!(parts[5])
power_limit_watts = to_float!(parts[6])
gpu_name = strip_whitespace!(parts[3])

# GPU power metric
.metric_type = "gpu_power"
.power_draw = power_draw_watts
.power_limit = power_limit_watts
.power_percent = if power_limit_watts > 0 { ((power_draw_watts / power_limit_watts) ?? 0.0) * 100.0 } else { 0.0 }
.gpu_name    = gpu_name
.host        = get_env_var("HOSTNAME") ?? "unknown-host"
.timestamp   = format_timestamp!(now(), format: "%+")
'''

# GPU encoder/decoder utilization transform
[transforms.format_gpu_encoder_decoder]
type   = "remap"
inputs = ["gpu_metrics"]
source = '''
parts = split!(.message, ",")
encoder_utilization = to_float!(parts[10])
decoder_utilization = to_float!(parts[11])
gpu_name = strip_whitespace!(parts[3])

# GPU encoder/decoder metric
.metric_type = "gpu_encoder_decoder"
.encoder_utilization = encoder_utilization
.decoder_utilization = decoder_utilization
.gpu_name    = gpu_name
.host        = get_env_var("HOSTNAME") ?? "unknown-host"
.timestamp   = format_timestamp!(now(), format: "%+")
'''

# GPU fan speed and performance state transform
[transforms.format_gpu_fan_pstate]
type   = "remap"
inputs = ["gpu_metrics"]
source = '''
parts = split!(.message, ",")
fan_speed_percent = to_float!(parts[7])
pstate = strip_whitespace!(parts[12])
gpu_name = strip_whitespace!(parts[3])

# GPU fan and pstate metric
.metric_type = "gpu_fan_pstate"
.fan_speed = fan_speed_percent
.performance_state = pstate
.gpu_name    = gpu_name
.host        = get_env_var("HOSTNAME") ?? "unknown-host"
.timestamp   = format_timestamp!(now(), format: "%+")
'''

EOF
    fi

    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
[transforms.rewrite_mem_names]
type   = "remap"
inputs = ["metrics_to_logs"]
source = '''
if starts_with!(.name, "memory_") {
  .name = "host_" + to_string!(.name)
}
'''

################################ 3. FILTER & TAG ##############################

[transforms.format_metrics]
type   = "remap"
inputs = ["rewrite_mem_names"]
source = '''
# ----- derive a reliable host field -----
hostname = if !is_null(.host) {
             .host
           } else if !is_null(.tags.host) {
             .tags.host
           } else {
             get_env_var("HOSTNAME") ?? "unknown-host"
           }

# -------- filter + rename the metrics we care about --------
if .name == "host_memory_used_bytes" {
  .metric_type = "memory_used"
  .value       = .gauge.value
  .host        = hostname

} else if .name == "host_memory_total_bytes" {
  .metric_type = "memory_total"
  .value       = .gauge.value
  .host        = hostname

} else if (.name == "host_cpu_seconds_total" || .name == "cpu_seconds_total") && .tags.mode == "idle" {
  .metric_type = "cpu_idle"
  .value       = .counter.value
  .cpu         = .tags.cpu
  .host        = hostname

} else if (.name == "host_cpu_seconds_total" || .name == "cpu_seconds_total") {
  .metric_type = "cpu_total"
  .value       = .counter.value
  .cpu         = .tags.cpu
  .host        = hostname

} else {
  abort   # drop everything else
}

.timestamp = format_timestamp!(now(), format: "%+")
'''

# Network metrics transform
[transforms.format_network]
type   = "remap"
inputs = ["rewrite_mem_names"]
source = '''
hostname = if !is_null(.host) {
             .host
           } else if !is_null(.tags.host) {
             .tags.host
           } else {
             get_env_var("HOSTNAME") ?? "unknown-host"
           }

interface = .tags.device

if .name == "network_receive_bytes_total" {
  .metric_type = "network_rx_bytes"
  .value       = .counter.value
  .interface   = interface
  .host        = hostname
} else if .name == "network_transmit_bytes_total" {
  .metric_type = "network_tx_bytes"
  .value       = .counter.value
  .interface   = interface
  .host        = hostname
} else if .name == "network_receive_packets_total" {
  .metric_type = "network_rx_packets"
  .value       = .counter.value
  .interface   = interface
  .host        = hostname
} else if .name == "network_transmit_packets_total" {
  .metric_type = "network_tx_packets"
  .value       = .counter.value
  .interface   = interface
  .host        = hostname
} else if .name == "network_receive_errs_total" {
  .metric_type = "network_rx_errors"
  .value       = .counter.value
  .interface   = interface
  .host        = hostname
} else if .name == "network_transmit_errs_total" {
  .metric_type = "network_tx_errors"
  .value       = .counter.value
  .interface   = interface
  .host        = hostname
} else if .name == "network_receive_drop_total" {
  .metric_type = "network_rx_dropped"
  .value       = .counter.value
  .interface   = interface
  .host        = hostname
} else if .name == "network_transmit_drop_total" {
  .metric_type = "network_tx_dropped"
  .value       = .counter.value
  .interface   = interface
  .host        = hostname
} else {
  abort
}

.timestamp = format_timestamp!(now(), format: "%+")
'''

# Storage/Filesystem metrics transform
[transforms.format_storage]
type   = "remap"
inputs = ["rewrite_mem_names"]
source = '''
hostname = if !is_null(.host) {
             .host
           } else if !is_null(.tags.host) {
             .tags.host
           } else {
             get_env_var("HOSTNAME") ?? "unknown-host"
           }

filesystem = .tags.filesystem
device = .tags.device

if .name == "filesystem_total_bytes" {
  .metric_type = "disk_total"
  .value       = .gauge.value
  .filesystem  = filesystem
  .device      = device
  .host        = hostname
} else if .name == "filesystem_used_bytes" {
  .metric_type = "disk_used"
  .value       = .gauge.value
  .filesystem  = filesystem
  .device      = device
  .host        = hostname
} else if .name == "filesystem_free_bytes" {
  .metric_type = "disk_free"
  .value       = .gauge.value
  .filesystem  = filesystem
  .device      = device
  .host        = hostname
} else if .name == "disk_read_bytes_total" {
  .metric_type = "disk_read_bytes"
  .value       = .counter.value
  .device      = device
  .host        = hostname
} else if .name == "disk_written_bytes_total" {
  .metric_type = "disk_write_bytes"
  .value       = .counter.value
  .device      = device
  .host        = hostname
} else {
  abort
}

.timestamp = format_timestamp!(now(), format: "%+")
'''

# System uptime and load metrics transform
[transforms.format_system]
type   = "remap"
inputs = ["rewrite_mem_names"]
source = '''
hostname = if !is_null(.host) {
             .host
           } else if !is_null(.tags.host) {
             .tags.host
           } else {
             get_env_var("HOSTNAME") ?? "unknown-host"
           }

if .name == "uptime" {
  .metric_type = "uptime"
  .value       = .gauge.value
  .host        = hostname
} else if .name == "boot_time" {
  .metric_type = "boot_time"
  .value       = .gauge.value
  .host        = hostname
} else if .name == "load1" {
  .metric_type = "load_1min"
  .value       = .gauge.value
  .host        = hostname
} else if .name == "load5" {
  .metric_type = "load_5min"
  .value       = .gauge.value
  .host        = hostname
} else if .name == "load15" {
  .metric_type = "load_15min"
  .value       = .gauge.value
  .host        = hostname
} else if .name == "host_logical_cpus" {
  .metric_type = "cpu_logical_count"
  .value       = .gauge.value
  .host        = hostname
} else if .name == "host_physical_cpus" {
  .metric_type = "cpu_physical_count"
  .value       = .gauge.value
  .host        = hostname
} else {
  abort
}

.timestamp = format_timestamp!(now(), format: "%+")
'''

################################ 4. PRODUCTION SINK ###########################

[sinks.websocket_out]
type    = "websocket_server"
EOF

    # Set inputs based on GPU configuration
    if [ "${gpu_enabled}" = "true" ]; then
        echo 'inputs  = ["format_metrics", "format_network", "format_storage", "format_system", "format_system_info", "format_gpu", "format_gpu_memory", "format_gpu_temperature", "format_gpu_clocks", "format_gpu_power", "format_gpu_encoder_decoder", "format_gpu_fan_pstate"]' >> "${VECTOR_CONFIG_DIR}/vector.toml"
    else
        echo 'inputs  = ["format_metrics", "format_network", "format_storage", "format_system", "format_system_info"]' >> "${VECTOR_CONFIG_DIR}/vector.toml"
    fi

    # Set bind address based on installation mode
    # In proxy mode, bind to localhost only; in standalone, bind to all interfaces
    local bind_address="0.0.0.0:${ACTVT_VECTOR_PORT}"
    if [ "$SELECTED_MODE" = "proxy" ]; then
        bind_address="127.0.0.1:${ACTVT_VECTOR_PORT}"
        progress "Vector will bind to localhost only (proxy mode)"
    else
        progress "Vector will bind to all interfaces (standalone mode)"
    fi

    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << EOF
address = "${bind_address}"

encoding.codec            = "json"
encoding.timestamp_format = "rfc3339"
EOF

    # Add TLS configuration
    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'

[sinks.websocket_out.tls]
enabled  = true
crt_file = "/etc/vector/certs/server.crt"
key_file = "/etc/vector/certs/server.key"
EOF

    # Add mTLS configuration if enabled
    if [[ "${ACTVT_ENABLE_MTLS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'
ca_file  = "/etc/vector/certs/mtls/ca.crt"
verify_certificate = true
EOF
        progress "mTLS client certificate verification enabled"
    else
        progress "mTLS client certificate verification disabled (using TLS only)"
    fi

    cat >> "${VECTOR_CONFIG_DIR}/vector.toml" << 'EOF'

################################ 5. API #######################################

[api]
enabled = true
EOF

    # Set proper permissions
    chown -R vector:vector "${VECTOR_CONFIG_DIR}" || true
    chmod 755 "${VECTOR_CONFIG_DIR}"
    chmod 644 "${VECTOR_CONFIG_DIR}/vector.toml"

    # Validate configuration (will fail if certs don't exist yet, but that's expected)
    progress "Validating configuration..."
    if vector validate "${VECTOR_CONFIG_DIR}/vector.toml" >> "${ACTVT_LOG_FILE}" 2>&1; then
        log SUCCESS "Vector configuration valid"
    else
        # Expected to fail without TLS certs
        log INFO "Configuration created (TLS certificates required before starting)"
    fi

    log SUCCESS "Vector configuration complete"
}

###############################################################################
#                        Web Server Detection                                 #
###############################################################################

detect_existing_webserver() {
    log INFO "Checking for existing web server..."

    # Check if ports 80 or 443 are in use
    local port_80_in_use=false
    local port_443_in_use=false

    # Try lsof first, fallback to ss
    if command -v lsof &> /dev/null; then
        if lsof -ti:80 &> /dev/null; then
            port_80_in_use=true
        fi
        if lsof -ti:443 &> /dev/null; then
            port_443_in_use=true
        fi
    elif command -v ss &> /dev/null; then
        if ss -tlnp 2>/dev/null | grep -q ':80 '; then
            port_80_in_use=true
        fi
        if ss -tlnp 2>/dev/null | grep -q ':443 '; then
            port_443_in_use=true
        fi
    fi

    # Detect which web server is running
    if [ "$port_80_in_use" = true ] || [ "$port_443_in_use" = true ]; then
        if systemctl is-active --quiet nginx 2>/dev/null || pgrep nginx &> /dev/null; then
            EXISTING_WEBSERVER="nginx"
            progress "Nginx detected on port 80/443"
            return 0
        elif systemctl is-active --quiet apache2 2>/dev/null || pgrep apache2 &> /dev/null; then
            EXISTING_WEBSERVER="apache"
            progress "Apache detected on port 80/443"
            return 0
        elif systemctl is-active --quiet httpd 2>/dev/null || pgrep httpd &> /dev/null; then
            EXISTING_WEBSERVER="httpd"
            progress "Apache/httpd detected on port 80/443"
            return 0
        else
            EXISTING_WEBSERVER="unknown"
            log WARNING "Unknown service using port 80/443"
            return 0
        fi
    fi

    progress "No existing web server detected"
    return 0
}

determine_installation_mode() {
    log INFO "Determining installation mode..."

    # Force standalone mode if requested
    if [[ "${ACTVT_FORCE_STANDALONE}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        SELECTED_MODE="standalone"
        log INFO "Installation mode: standalone (forced via ACTVT_FORCE_STANDALONE)"
        return 0
    fi

    # Use explicit mode if provided
    if [ "${ACTVT_INSTALL_MODE}" != "auto" ]; then
        SELECTED_MODE="${ACTVT_INSTALL_MODE}"
        log INFO "Installation mode: ${SELECTED_MODE} (explicitly set)"
        return 0
    fi

    # Auto-detect based on existing web server
    if [ -n "$EXISTING_WEBSERVER" ] && [ "$EXISTING_WEBSERVER" != "unknown" ]; then
        SELECTED_MODE="proxy"
        log INFO "Installation mode: proxy (detected ${EXISTING_WEBSERVER})"
    else
        SELECTED_MODE="standalone"
        log INFO "Installation mode: standalone (no web server detected)"
    fi

    return 0
}

###############################################################################
#                           TLS Certificate Setup                             #
###############################################################################

setup_tls() {
    log STEP "Setting up TLS Certificates"

    # Use required domain from environment
    local domain="${ACTVT_DOMAIN}"
    log INFO "Using domain: ${domain:0:3}***${domain: -4}"

    # Verify DNS resolution
    progress "Verifying DNS resolution..."
    if ! host "${domain}" &> /dev/null; then
        log WARNING "Domain does not resolve. Please ensure DNS is configured correctly."
        log WARNING "Certificate acquisition may fail if DNS is not properly configured."

        # Check environment variable first
        if [ -n "${ACTVT_CONTINUE_WITHOUT_DNS:-}" ]; then
            if [[ "${ACTVT_CONTINUE_WITHOUT_DNS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
                log WARNING "Continuing without DNS resolution (ACTVT_CONTINUE_WITHOUT_DNS=yes)"
            else
                error_exit "DNS not configured (ACTVT_CONTINUE_WITHOUT_DNS=${ACTVT_CONTINUE_WITHOUT_DNS})"
            fi
        # In non-interactive mode, fail by default
        elif ! is_interactive; then
            error_exit "DNS not configured (non-interactive mode). Set ACTVT_CONTINUE_WITHOUT_DNS=yes to override"
        # Interactive mode - prompt user
        else
            read -p "Continue anyway? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                error_exit "Please configure DNS and try again"
            fi
        fi
    fi

    # Install Certbot
    progress "Installing Certbot..."
    case "${PKG_MANAGER}" in
        apt-get)
            ${PKG_INSTALL} certbot >> "${ACTVT_LOG_FILE}" 2>&1
            ;;
        yum|dnf)
            # Enable EPEL repository for CentOS/RHEL
            if [ "${OS_NAME}" = "centos" ] || [ "${OS_NAME}" = "rhel" ]; then
                ${PKG_INSTALL} epel-release >> "${ACTVT_LOG_FILE}" 2>&1 || true
            fi
            ${PKG_INSTALL} certbot >> "${ACTVT_LOG_FILE}" 2>&1
            ;;
    esac

    if ! command -v certbot &> /dev/null; then
        error_exit "Failed to install Certbot"
    fi
    progress "Certbot installed successfully"

    # Use required email from environment
    local email="${ACTVT_EMAIL}"

    # Check if certificate already exists
    if [ -d "/etc/letsencrypt/live/${domain}" ]; then
        log INFO "Certificate for domain already exists"

        # Check environment variable first
        local reuse_cert="yes"
        if [ -n "${ACTVT_REUSE_CERT:-}" ]; then
            reuse_cert="${ACTVT_REUSE_CERT}"
        # In non-interactive mode, reuse by default
        elif ! is_interactive; then
            reuse_cert="yes"
        # Interactive mode - prompt user
        else
            read -p "Reuse existing certificate? [Y/n] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                reuse_cert="no"
            fi
        fi

        if [[ "${reuse_cert}" =~ ^[Yy]([Ee][Ss])?$ ]] || [[ "${reuse_cert}" == "yes" ]]; then
            progress "Using existing certificate"
        else
            progress "Obtaining new certificate..."
            certbot certonly --standalone -d "${domain}" \
                --email "${email}" --agree-tos --non-interactive --force-renewal \
                >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to obtain Let's Encrypt certificate"
        fi
    else
        progress "Obtaining Let's Encrypt certificate..."

        # Choose certbot mode based on existing web server
        if [ "$SELECTED_MODE" = "proxy" ] && [ "$EXISTING_WEBSERVER" = "nginx" ]; then
            progress "Using webroot mode (nginx detected)..."

            # Ensure webroot directory exists
            mkdir -p "${ACTVT_NGINX_WEBROOT}/.well-known/acme-challenge"

            # Set proper permissions for webroot
            if id www-data &> /dev/null; then
                chown -R www-data:www-data "${ACTVT_NGINX_WEBROOT}/.well-known" 2>/dev/null || true
            elif id nginx &> /dev/null; then
                chown -R nginx:nginx "${ACTVT_NGINX_WEBROOT}/.well-known" 2>/dev/null || true
            fi

            log INFO "Using webroot: ${ACTVT_NGINX_WEBROOT}"
            log INFO "Ensure nginx is configured to serve .well-known/acme-challenge"

            certbot certonly --webroot -w "${ACTVT_NGINX_WEBROOT}" -d "${domain}" \
                --email "${email}" --agree-tos --non-interactive \
                >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to obtain certificate via webroot. Ensure nginx serves ${ACTVT_NGINX_WEBROOT}/.well-known"

        elif [ "$SELECTED_MODE" = "proxy" ] && [ -n "$EXISTING_WEBSERVER" ]; then
            log WARNING "Detected ${EXISTING_WEBSERVER} on port 80/443"
            log WARNING "To obtain certificates, you have two options:"
            log WARNING "1. Temporarily stop ${EXISTING_WEBSERVER}:"
            log WARNING "   sudo systemctl stop ${EXISTING_WEBSERVER}"
            log WARNING "   Then run this script again"
            log WARNING "   sudo systemctl start ${EXISTING_WEBSERVER}"
            log WARNING ""
            log WARNING "2. Use webroot mode manually:"
            log WARNING "   Set ACTVT_NGINX_WEBROOT to your web server's document root"
            error_exit "Cannot obtain certificate automatically with ${EXISTING_WEBSERVER} running on port 80"

        else
            # Standalone mode (default behavior)
            log INFO "Using standalone mode (requires port 80 to be temporarily accessible)"

            certbot certonly --standalone -d "${domain}" \
                --email "${email}" --agree-tos --non-interactive \
                >> "${ACTVT_LOG_FILE}" 2>&1 || \
                error_exit "Failed to obtain Let's Encrypt certificate. Ensure port 80 is accessible and not in use."
        fi
    fi

    # Install certificates for Vector by copying from Let's Encrypt
    progress "Installing certificates for Vector..."
    mkdir -p "${VECTOR_CERTS_DIR}"
    chmod 755 "${VECTOR_CERTS_DIR}"
    if ! install -o vector -g vector -m 644 \
        "/etc/letsencrypt/live/${domain}/fullchain.pem" "${VECTOR_CERTS_DIR}/server.crt"; then
        error_exit "Failed to install Vector certificate"
    fi
    if ! install -o vector -g vector -m 640 \
        "/etc/letsencrypt/live/${domain}/privkey.pem" "${VECTOR_CERTS_DIR}/server.key"; then
        error_exit "Failed to install Vector private key"
    fi
    progress "Certificates installed successfully"

    # Set up auto-renewal
    progress "Setting up automatic certificate renewal..."

    # Create renewal hook script
    local renewal_hook="/etc/letsencrypt/renewal-hooks/deploy/actvt-vector.sh"
    mkdir -p "$(dirname ${renewal_hook})"

    cat > "${renewal_hook}" << 'RENEWAL_EOF'
#!/bin/bash
set -euo pipefail

DOMAIN="${RENEWED_LINEAGE##*/}"
SRC="/etc/letsencrypt/live/${DOMAIN}"
DST="/etc/vector/certs"

logger -t actvt-renewal "Actvt: Deploying renewed certificate for ${DOMAIN}"

install -d -o vector -g vector -m 755 "${DST}"
install -o vector -g vector -m 644 "${SRC}/fullchain.pem" "${DST}/server.crt"
install -o vector -g vector -m 640 "${SRC}/privkey.pem" "${DST}/server.key"

if [ -f /etc/vector/vector.toml ]; then
  if systemctl reload vector 2>/dev/null; then
    :
  else
    systemctl restart vector || true
  fi
fi

if systemctl is-active --quiet nginx 2>/dev/null; then
  systemctl reload nginx || true
fi
RENEWAL_EOF

    chmod +x "${renewal_hook}"

    # Test renewal (dry-run)
    if certbot renew --dry-run >> "${ACTVT_LOG_FILE}" 2>&1; then
        progress "Auto-renewal configured successfully"
    else
        log WARNING "Auto-renewal test failed, but certificates are installed"
    fi

    # Store domain for later use
    echo "${domain}" > "${ACTVT_STATE_DIR}/domain"

    log SUCCESS "TLS certificates configured successfully"
}

###############################################################################
#                           mTLS Certificate Setup                            #
###############################################################################

setup_mtls() {
    log STEP "Setting up mTLS Client Authentication"

    # Check if mTLS should be enabled
    if [[ ! "${ACTVT_ENABLE_MTLS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        log INFO "mTLS disabled by default (using TLS only)"
        log INFO "Client certificate verification will NOT be required"
        log INFO "Set ACTVT_ENABLE_MTLS=yes to enable mTLS for enhanced security"
        return 0
    fi

    progress "Configuring mutual TLS (mTLS) for enhanced security..."

    # Create mTLS directory structure
    progress "Creating mTLS directory structure..."
    mkdir -p "${VECTOR_MTLS_CLIENTS_DIR}"
    chmod 755 "${VECTOR_MTLS_DIR}"
    chmod 755 "${VECTOR_MTLS_CLIENTS_DIR}"

    # Check if CA already exists
    if [ -f "${VECTOR_MTLS_DIR}/ca.crt" ] && [ -f "${VECTOR_MTLS_DIR}/ca.key" ]; then
        log INFO "mTLS CA certificate already exists"

        # Check environment variable first
        local reuse_ca="yes"
        if [ -n "${ACTVT_REUSE_MTLS_CA:-}" ]; then
            reuse_ca="${ACTVT_REUSE_MTLS_CA}"
        # In non-interactive mode, reuse by default
        elif ! is_interactive; then
            reuse_ca="yes"
        # Interactive mode - prompt user
        else
            read -p "Reuse existing mTLS CA certificate? [Y/n] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                reuse_ca="no"
            fi
        fi

        if [[ "${reuse_ca}" =~ ^[Yy]([Ee][Ss])?$ ]] || [[ "${reuse_ca}" == "yes" ]]; then
            progress "Using existing mTLS CA certificate"
        else
            progress "Generating new mTLS CA certificate..."
            # Backup existing CA
            local backup_ca_crt="$(mktemp -p "${ACTVT_BACKUP_DIR}" mtls-ca.crt.backup.XXXXXX)"
            local backup_ca_key="$(mktemp -p "${ACTVT_BACKUP_DIR}" mtls-ca.key.backup.XXXXXX)"
            cp "${VECTOR_MTLS_DIR}/ca.crt" "$backup_ca_crt" || true
            cp "${VECTOR_MTLS_DIR}/ca.key" "$backup_ca_key" || true
            progress "Existing CA backed up to $(basename "$backup_ca_crt") and $(basename "$backup_ca_key")"

            # Generate new CA
            generate_mtls_ca
        fi
    else
        progress "Generating mTLS Certificate Authority (CA)..."
        generate_mtls_ca
    fi

    # Generate initial client certificate
    progress "Generating initial client certificate..."
    local client_cn="${ACTVT_MTLS_CLIENT_CN}"

    if [ -f "${VECTOR_MTLS_CLIENTS_DIR}/${client_cn}.crt" ]; then
        log INFO "Client certificate '${client_cn}' already exists"

        # Check if we should regenerate
        local regen_client="no"
        if [ -n "${ACTVT_REGEN_CLIENT_CERT:-}" ]; then
            regen_client="${ACTVT_REGEN_CLIENT_CERT}"
        elif ! is_interactive; then
            regen_client="no"
        else
            read -p "Regenerate client certificate '${client_cn}'? [y/N] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                regen_client="yes"
            fi
        fi

        if [[ "${regen_client}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
            generate_mtls_client_cert "${client_cn}"
        else
            progress "Using existing client certificate"
        fi
    else
        generate_mtls_client_cert "${client_cn}"
    fi

    # Set proper ownership before creating bundle
    chown -R vector:vector "${VECTOR_MTLS_DIR}" || true

    # Create client certificate bundle for distribution
    progress "Creating client certificate bundle..."
    cd "${VECTOR_MTLS_DIR}"
    tar -czf "${client_cn}-bundle.tar.gz" \
        ca.crt \
        "clients/${client_cn}.crt" \
        "clients/${client_cn}-chain.crt" \
        "clients/${client_cn}.key" \
        >> "${ACTVT_LOG_FILE}" 2>&1

    chmod 600 "${client_cn}-bundle.tar.gz"
    progress "Client certificate bundle created: ${VECTOR_MTLS_DIR}/${client_cn}-bundle.tar.gz"

    # Create client certificate generation script
    progress "Creating client certificate generation script..."
    create_client_cert_generator

    log SUCCESS "mTLS configured successfully"
    log INFO "Client certificate bundle: ${VECTOR_MTLS_DIR}/${client_cn}-bundle.tar.gz"
    log INFO "Generate additional clients: sudo ${VECTOR_MTLS_DIR}/generate-client.sh <client-name>"
}

generate_mtls_ca() {
    local ca_key="${VECTOR_MTLS_DIR}/ca.key"
    local ca_crt="${VECTOR_MTLS_DIR}/ca.crt"
    local ca_days="${ACTVT_MTLS_CA_DAYS}"

    # Generate CA private key (4096-bit, no password for automation)
    progress "Generating CA private key (4096-bit)..."
    openssl genrsa -out "$ca_key" 4096 >> "${ACTVT_LOG_FILE}" 2>&1 || \
        error_exit "Failed to generate CA private key"

    # Create self-signed CA certificate
    progress "Creating self-signed CA certificate (valid for ${ca_days} days)..."
    openssl req -new -x509 -sha256 -days "${ca_days}" \
        -key "$ca_key" \
        -out "$ca_crt" \
        -subj "/CN=Actvt-CA/O=Actvt/C=US" \
        >> "${ACTVT_LOG_FILE}" 2>&1 || \
        error_exit "Failed to create CA certificate"

    # Set proper permissions
    chmod 600 "$ca_key"
    chmod 644 "$ca_crt"

    progress "CA certificate generated successfully"
}

generate_mtls_client_cert() {
    local client_name="$1"
    local client_key="${VECTOR_MTLS_CLIENTS_DIR}/${client_name}.key"
    local client_csr="${VECTOR_MTLS_CLIENTS_DIR}/${client_name}.csr"
    local client_crt="${VECTOR_MTLS_CLIENTS_DIR}/${client_name}.crt"
    local ca_crt="${VECTOR_MTLS_DIR}/ca.crt"
    local ca_key="${VECTOR_MTLS_DIR}/ca.key"
    local client_days="${ACTVT_MTLS_CLIENT_DAYS}"

    # Generate client private key (2048-bit)
    progress "Generating client private key for '${client_name}'..."
    openssl genrsa -out "$client_key" 2048 >> "${ACTVT_LOG_FILE}" 2>&1 || \
        error_exit "Failed to generate client private key"

    # Create Certificate Signing Request (CSR)
    progress "Creating certificate signing request..."
    openssl req -new \
        -key "$client_key" \
        -out "$client_csr" \
        -subj "/CN=${client_name}/O=Actvt" \
        >> "${ACTVT_LOG_FILE}" 2>&1 || \
        error_exit "Failed to create CSR"

    # Sign the client certificate with CA
    progress "Signing client certificate (valid for ${client_days} days)..."
    openssl x509 -req -days "${client_days}" -sha256 \
        -in "$client_csr" \
        -CA "$ca_crt" \
        -CAkey "$ca_key" \
        -CAcreateserial \
        -out "$client_crt" \
        -extfile <(printf "extendedKeyUsage=clientAuth") \
        >> "${ACTVT_LOG_FILE}" 2>&1 || \
        error_exit "Failed to sign client certificate"

    # Create chained certificate file (client cert + CA cert)
    local client_chain="${VECTOR_MTLS_CLIENTS_DIR}/${client_name}-chain.crt"
    progress "Creating certificate chain file..."
    cat "$client_crt" "$ca_crt" > "$client_chain" || \
        error_exit "Failed to create certificate chain"

    # Set proper permissions
    chmod 644 "$client_crt"
    chmod 644 "$client_chain"
    chmod 600 "$client_key"

    # Set proper ownership
    chown vector:vector "$client_crt" "$client_chain" "$client_key" 2>/dev/null || true

    # Clean up CSR
    rm -f "$client_csr"

    progress "Client certificate '${client_name}' generated successfully"
}

create_client_cert_generator() {
    local script_path="${VECTOR_MTLS_DIR}/generate-client.sh"

    cat > "$script_path" << 'GENCERT_EOF'
#!/bin/bash
###############################################################################
#                   Actvt mTLS Client Certificate Generator                  #
###############################################################################
set -euo pipefail

if [ "$EUID" -ne 0 ]; then
    echo "ERROR: Please run as root or with sudo"
    exit 1
fi

CLIENT_NAME="${1:-}"
if [ -z "$CLIENT_NAME" ]; then
    echo "Usage: $0 <client-name>"
    echo "Example: $0 actvt-client-002"
    exit 1
fi

# Configuration
MTLS_DIR="/etc/vector/certs/mtls"
CLIENT_DIR="${MTLS_DIR}/clients"
CA_CRT="${MTLS_DIR}/ca.crt"
CA_KEY="${MTLS_DIR}/ca.key"
CLIENT_KEY="${CLIENT_DIR}/${CLIENT_NAME}.key"
CLIENT_CSR="${CLIENT_DIR}/${CLIENT_NAME}.csr"
CLIENT_CRT="${CLIENT_DIR}/${CLIENT_NAME}.crt"
BUNDLE="${MTLS_DIR}/${CLIENT_NAME}-bundle.tar.gz"
CLIENT_DAYS="${ACTVT_MTLS_CLIENT_DAYS:-365}"

# Verify CA exists
if [ ! -f "$CA_CRT" ] || [ ! -f "$CA_KEY" ]; then
    echo "ERROR: CA certificates not found in ${MTLS_DIR}"
    echo "Please run the installation script to set up mTLS first"
    exit 1
fi

echo "Generating client certificate: ${CLIENT_NAME}"
echo "Certificate validity: ${CLIENT_DAYS} days"
echo ""

# Check if certificate already exists
if [ -f "$CLIENT_CRT" ]; then
    read -p "Certificate '${CLIENT_NAME}' already exists. Overwrite? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 0
    fi
    echo "Regenerating certificate..."
fi

# Generate client private key
echo "→ Generating client private key..."
openssl genrsa -out "$CLIENT_KEY" 2048 2>/dev/null || {
    echo "ERROR: Failed to generate private key"
    exit 1
}

# Create CSR
echo "→ Creating certificate signing request..."
openssl req -new \
    -key "$CLIENT_KEY" \
    -out "$CLIENT_CSR" \
    -subj "/CN=${CLIENT_NAME}/O=Actvt" 2>/dev/null || {
    echo "ERROR: Failed to create CSR"
    exit 1
}

# Sign certificate
echo "→ Signing certificate with CA..."
openssl x509 -req -days "${CLIENT_DAYS}" -sha256 \
    -in "$CLIENT_CSR" \
    -CA "$CA_CRT" \
    -CAkey "$CA_KEY" \
    -CAcreateserial \
    -out "$CLIENT_CRT" \
    -extfile <(printf "extendedKeyUsage=clientAuth") 2>/dev/null || {
    echo "ERROR: Failed to sign certificate"
    exit 1
}

# Create chained certificate file
echo "→ Creating certificate chain file..."
CLIENT_CHAIN="${CLIENT_DIR}/${CLIENT_NAME}-chain.crt"
cat "$CLIENT_CRT" "$CA_CRT" > "$CLIENT_CHAIN" || {
    echo "ERROR: Failed to create certificate chain"
    exit 1
}

# Set permissions
chmod 644 "$CLIENT_CRT"
chmod 644 "$CLIENT_CHAIN"
chmod 600 "$CLIENT_KEY"
chown vector:vector "$CLIENT_CRT" "$CLIENT_CHAIN" "$CLIENT_KEY" 2>/dev/null || true

# Clean up CSR
rm -f "$CLIENT_CSR"

# Create distribution bundle
echo "→ Creating distribution bundle..."
cd "$MTLS_DIR"
tar -czf "$BUNDLE" \
    ca.crt \
    "clients/${CLIENT_NAME}.crt" \
    "clients/${CLIENT_NAME}-chain.crt" \
    "clients/${CLIENT_NAME}.key" 2>/dev/null || {
    echo "ERROR: Failed to create bundle"
    exit 1
}
chmod 600 "$BUNDLE"

echo ""
echo "✓ Client certificate generated successfully"
echo "✓ Certificate: ${CLIENT_CRT}"
echo "✓ Certificate chain: ${CLIENT_CHAIN}"
echo "✓ Private key: ${CLIENT_KEY}"
echo "✓ Bundle: ${BUNDLE}"
echo ""
echo "Certificate details:"
openssl x509 -in "$CLIENT_CRT" -noout -subject -dates 2>/dev/null
echo ""
echo "To distribute to the client:"
echo "  scp ${BUNDLE} user@client-machine:~/"
echo ""
echo "On the client machine, extract the bundle:"
echo "  tar -xzf ${CLIENT_NAME}-bundle.tar.gz"
echo ""
echo "Usage (use the -chain.crt file for mTLS):"
echo "  curl --cert clients/${CLIENT_NAME}-chain.crt \\"
echo "       --key clients/${CLIENT_NAME}.key \\"
echo "       --cacert ca.crt \\"
echo "       https://your-domain/actvt/health"
echo ""
GENCERT_EOF

    chmod +x "$script_path"
    progress "Client certificate generator created at ${script_path}"
}

###############################################################################
#                       Nginx Reverse Proxy Configuration                     #
###############################################################################

configure_nginx_proxy() {
    log STEP "Configuring Nginx Reverse Proxy"

    # Only run in proxy mode with nginx
    if [ "$SELECTED_MODE" != "proxy" ] || [ "$EXISTING_WEBSERVER" != "nginx" ]; then
        log INFO "Skipping nginx configuration (not in proxy mode with nginx)"
        return 0
    fi

    local domain="${ACTVT_DOMAIN}"
    local nginx_config="/etc/nginx/sites-available/actvt-vector"
    local nginx_enabled="/etc/nginx/sites-enabled/actvt-vector"
    local nginx_snippet="/etc/nginx/snippets/actvt-vector-location.conf"

    progress "Creating nginx configuration for Vector WebSocket..."

    # Detect potential conflict with existing server block for this domain
    local conflict=false
    if nginx -T >/dev/null 2>&1; then
        if nginx -T 2>/dev/null | grep -E "server_name\s+${domain}(;|\s)" >/dev/null; then
            conflict=true
        fi
    fi

    # Backup existing config if it exists
    if [ -f "$nginx_config" ]; then
        backup_file="$(mktemp -p \"${ACTVT_BACKUP_DIR}\" actvt-vector.nginx.backup.XXXXXX)"
        cp "$nginx_config" "$backup_file" || true
        progress "Existing nginx config backed up to $(basename \"$backup_file\")"
    fi

    if [ "$conflict" = true ]; then
        mkdir -p "/etc/nginx/snippets"
        cat > "$nginx_snippet" << NGINX_SNIPPET
# Actvt Vector WebSocket Configuration Snippet
# Add these directives to your existing server block

NGINX_SNIPPET

        # Add mTLS configuration if enabled
        if [[ "${ACTVT_ENABLE_MTLS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
            cat >> "$nginx_snippet" << 'NGINX_MTLS_SNIPPET'
# mTLS client certificate verification (add to server block)
# IMPORTANT: Add these lines at the server level, not inside location blocks
#
# ssl_client_certificate /etc/vector/certs/mtls/ca.crt;
# ssl_verify_client on;
# ssl_verify_depth 2;
#

NGINX_MTLS_SNIPPET
        fi

        cat >> "$nginx_snippet" << NGINX_SNIPPET
# WebSocket proxy location block
location /actvt {
    proxy_pass https://127.0.0.1:${ACTVT_VECTOR_PORT};
    proxy_http_version 1.1;
    proxy_set_header Upgrade \$http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host \$host;
    proxy_set_header X-Real-IP \$remote_addr;
    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto \$scheme;
    proxy_read_timeout 86400;
    proxy_send_timeout 86400;
    proxy_connect_timeout 60;
    proxy_buffering off;
    proxy_ssl_server_name on;
    proxy_ssl_verify off;
}

location = /actvt/health {
    access_log off;
    return 200 "OK\n";
    add_header Content-Type text/plain;
}
NGINX_SNIPPET
        chmod 644 "$nginx_snippet" || true
        log WARNING "An existing nginx server block for ${domain} was detected."
        log INFO "Created snippet at ${nginx_snippet}. Include it inside your existing server block, e.g.:"
        echo "    include ${nginx_snippet};" | tee -a "${ACTVT_LOG_FILE}" >/dev/null

        if [[ "${ACTVT_ENABLE_MTLS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
            log WARNING "mTLS is enabled. You MUST uncomment the ssl_client_certificate directives in the snippet"
            log WARNING "and add them to your server block at the server level (not inside location blocks)."
        fi

        log INFO "Then reload nginx: systemctl reload nginx"
        log SUCCESS "Nginx reverse proxy snippet generated"
        log INFO "Vector WebSocket will be accessible at: wss://${domain}/actvt after you include the snippet"
        return 0
    fi

    # Create nginx configuration for Vector proxy (dedicated server block)
    cat > "$nginx_config" << NGINX_EOF
# Actvt Vector WebSocket Proxy Configuration
# Generated by Actvt installation script

server {
    listen 443 ssl http2;
    server_name ${domain};

    # SSL certificates managed by certbot
    ssl_certificate /etc/letsencrypt/live/${domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${domain}/privkey.pem;

    # SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
EOF

    # Add mTLS configuration if enabled
    if [[ "${ACTVT_ENABLE_MTLS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        cat >> "$nginx_config" << 'NGINX_MTLS_EOF'

    # mTLS client certificate verification
    ssl_client_certificate /etc/vector/certs/mtls/ca.crt;
    ssl_verify_client on;
    ssl_verify_depth 2;
NGINX_MTLS_EOF
        progress "Nginx mTLS client verification enabled"
    fi

    cat >> "$nginx_config" << NGINX_EOF

    # Actvt Vector WebSocket endpoint
    location /actvt {
        # Proxy to local Vector WebSocket server
        proxy_pass https://127.0.0.1:${ACTVT_VECTOR_PORT};

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";

        # Proxy headers
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # WebSocket timeouts (24 hours)
        proxy_read_timeout 86400;
        proxy_send_timeout 86400;
        proxy_connect_timeout 60;

        # Disable buffering for WebSocket
        proxy_buffering off;

        # Upstream TLS options
        proxy_ssl_server_name on;
        proxy_ssl_verify off;
    }

    # Health check endpoint (optional)
    location /actvt/health {
        access_log off;
        return 200 "OK\n";
        add_header Content-Type text/plain;
    }
}
NGINX_EOF

    progress "Nginx configuration created at $nginx_config"

    # Enable the site
    if [ -d "/etc/nginx/sites-enabled" ]; then
        ln -sf "$nginx_config" "$nginx_enabled"
        progress "Nginx site enabled"
    else
        log WARNING "sites-enabled directory not found. Include $nginx_config in your nginx config manually."
    fi

    # Test nginx configuration
    progress "Testing nginx configuration..."
    if nginx -t >> "${ACTVT_LOG_FILE}" 2>&1; then
        progress "Nginx configuration is valid"

        # Reload nginx
        progress "Reloading nginx..."
        if systemctl reload nginx >> "${ACTVT_LOG_FILE}" 2>&1; then
            progress "Nginx reloaded successfully"
        else
            log WARNING "Failed to reload nginx. You may need to reload it manually."
        fi
    else
        log ERROR "Nginx configuration test failed"
        log ERROR "Please check $nginx_config and fix any errors"
        error_exit "Nginx configuration is invalid"
    fi

    log SUCCESS "Nginx reverse proxy configured successfully"
    log INFO "Vector WebSocket accessible at: wss://${domain}/actvt"
}

###############################################################################
#                          Firewall Configuration                             #
###############################################################################

configure_firewall() {
    log STEP "Configuring Firewall"

    # Check if firewall configuration should be skipped
    local configure_fw="yes"
    if [ -n "${ACTVT_CONFIGURE_FIREWALL:-}" ]; then
        configure_fw="${ACTVT_CONFIGURE_FIREWALL}"
    elif ! is_interactive; then
        configure_fw="yes"
    fi

    if [[ ! "${configure_fw}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        log INFO "Skipping firewall configuration (ACTVT_CONFIGURE_FIREWALL=${configure_fw})"
        log INFO "Please ensure ports 80, 443, and 4096 are accessible"
        return 0
    fi

    # Detect firewall
    local firewall_type=""
    if command -v ufw &> /dev/null; then
        firewall_type="ufw"
    elif command -v firewall-cmd &> /dev/null; then
        firewall_type="firewalld"
    elif command -v iptables &> /dev/null; then
        firewall_type="iptables"
    else
        log WARNING "No firewall detected. Please configure firewall manually."
        log INFO "Required ports: 80 (HTTP), 443 (HTTPS), 4096 (WebSocket)"
        return 0
    fi

    progress "Detected firewall: ${firewall_type}"

    case "${firewall_type}" in
        ufw)
            progress "Configuring UFW..."

            # Enable UFW if not already enabled
            if ! ufw status | grep -q "Status: active"; then
                log WARNING "UFW is not active. Enabling UFW..."
                # Allow SSH first to prevent lockout
                ufw allow 22/tcp >> "${ACTVT_LOG_FILE}" 2>&1
                ufw --force enable >> "${ACTVT_LOG_FILE}" 2>&1
            fi

            # Check which ports are already open
            local port_80_open=false
            local port_443_open=false
            local port_vector_open=false

            if ufw status | grep -qE "^80/tcp.*ALLOW"; then
                port_80_open=true
            fi
            if ufw status | grep -qE "^443/tcp.*ALLOW"; then
                port_443_open=true
            fi
            if ufw status | grep -qE "^${ACTVT_VECTOR_PORT}/tcp.*ALLOW"; then
                port_vector_open=true
            fi

            # In proxy mode, ports 80/443 are likely already open
            if [ "$SELECTED_MODE" = "proxy" ]; then
                if [ "$port_80_open" = true ] && [ "$port_443_open" = true ]; then
                    progress "Ports 80 and 443 already open (existing web server)"
                else
                    [ "$port_80_open" = false ] && ufw allow 80/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 80"
                    [ "$port_443_open" = false ] && ufw allow 443/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 443"
                fi
                # In proxy mode, Vector port doesn't need to be exposed
                progress "Skipping port ${ACTVT_VECTOR_PORT} (proxy mode - localhost only)"
            else
                # Standalone mode - open all ports
                [ "$port_80_open" = false ] && ufw allow 80/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 80"
                [ "$port_443_open" = false ] && ufw allow 443/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 443"
                [ "$port_vector_open" = false ] && ufw allow ${ACTVT_VECTOR_PORT}/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port ${ACTVT_VECTOR_PORT}"
            fi

            progress "Firewall rules configured"
            ;;

        firewalld)
            progress "Configuring firewalld..."

            # Start firewalld if not running
            if ! systemctl is-active --quiet firewalld; then
                systemctl start firewalld
            fi

            # Check which ports are already open
            local port_80_open=false
            local port_443_open=false
            local port_vector_open=false

            if firewall-cmd --list-ports 2>/dev/null | grep -q "80/tcp"; then
                port_80_open=true
            fi
            if firewall-cmd --list-ports 2>/dev/null | grep -q "443/tcp"; then
                port_443_open=true
            fi
            if firewall-cmd --list-ports 2>/dev/null | grep -q "${ACTVT_VECTOR_PORT}/tcp"; then
                port_vector_open=true
            fi

            # In proxy mode, ports 80/443 are likely already open
            if [ "$SELECTED_MODE" = "proxy" ]; then
                if [ "$port_80_open" = true ] && [ "$port_443_open" = true ]; then
                    progress "Ports 80 and 443 already open (existing web server)"
                else
                    [ "$port_80_open" = false ] && firewall-cmd --permanent --add-port=80/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 80"
                    [ "$port_443_open" = false ] && firewall-cmd --permanent --add-port=443/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 443"
                fi
                # In proxy mode, Vector port doesn't need to be exposed
                progress "Skipping port ${ACTVT_VECTOR_PORT} (proxy mode - localhost only)"
            else
                # Standalone mode - open all ports
                [ "$port_80_open" = false ] && firewall-cmd --permanent --add-port=80/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 80"
                [ "$port_443_open" = false ] && firewall-cmd --permanent --add-port=443/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port 443"
                [ "$port_vector_open" = false ] && firewall-cmd --permanent --add-port=${ACTVT_VECTOR_PORT}/tcp >> "${ACTVT_LOG_FILE}" 2>&1 && progress "Opened port ${ACTVT_VECTOR_PORT}"
            fi

            firewall-cmd --reload >> "${ACTVT_LOG_FILE}" 2>&1
            progress "Firewall rules configured"
            ;;

        iptables)
            progress "Configuring iptables..."

            # In proxy mode, ports 80/443 are likely already open
            if [ "$SELECTED_MODE" = "proxy" ]; then
                # Check if rules already exist before adding
                if ! iptables -C INPUT -p tcp --dport 80 -j ACCEPT 2>/dev/null; then
                    iptables -I INPUT -p tcp --dport 80 -j ACCEPT
                    progress "Opened port 80"
                else
                    progress "Port 80 already open"
                fi

                if ! iptables -C INPUT -p tcp --dport 443 -j ACCEPT 2>/dev/null; then
                    iptables -I INPUT -p tcp --dport 443 -j ACCEPT
                    progress "Opened port 443"
                else
                    progress "Port 443 already open"
                fi

                # In proxy mode, Vector port doesn't need to be exposed
                progress "Skipping port ${ACTVT_VECTOR_PORT} (proxy mode - localhost only)"
            else
                # Standalone mode - add all rules if they don't exist
                iptables -C INPUT -p tcp --dport 80 -j ACCEPT 2>/dev/null || \
                    iptables -I INPUT -p tcp --dport 80 -j ACCEPT
                iptables -C INPUT -p tcp --dport 443 -j ACCEPT 2>/dev/null || \
                    iptables -I INPUT -p tcp --dport 443 -j ACCEPT
                iptables -C INPUT -p tcp --dport ${ACTVT_VECTOR_PORT} -j ACCEPT 2>/dev/null || \
                    iptables -I INPUT -p tcp --dport ${ACTVT_VECTOR_PORT} -j ACCEPT
            fi

            # Try to save rules
            if command -v iptables-save &> /dev/null; then
                mkdir -p /etc/iptables 2>/dev/null || true
                iptables-save > /etc/iptables/rules.v4 2>/dev/null || \
                    log WARNING "Could not persist iptables rules. They may not survive reboot."
            fi

            progress "Firewall rules configured"
            ;;
    esac

    log SUCCESS "Firewall configuration complete"
}

###############################################################################
#                          Service Management                                 #
###############################################################################

start_vector_service() {
    log STEP "Starting Vector Service"

    # Stop Vector if running (to clear any demo/default config)
    if systemctl is-active --quiet vector; then
        progress "Stopping existing Vector service..."
        systemctl stop vector >> "${ACTVT_LOG_FILE}" 2>&1 || true

        # Wait for service to fully stop (poll up to 30 seconds)
        local wait_count=0
        while systemctl is-active --quiet vector && [ $wait_count -lt 30 ]; do
            sleep 1
            wait_count=$((wait_count + 1))
        done

        if systemctl is-active --quiet vector; then
            log WARNING "Service did not stop cleanly, forcing stop..."
            systemctl kill vector >> "${ACTVT_LOG_FILE}" 2>&1 || true
            sleep 2
        else
            progress "Service stopped successfully"
        fi
    fi

    # Create systemd override to explicitly use our config file
    progress "Configuring Vector service to use /etc/vector/vector.toml..."
    mkdir -p /etc/systemd/system/vector.service.d
    cat > /etc/systemd/system/vector.service.d/override.conf << 'OVERRIDE_EOF'
[Service]
ExecStart=
ExecStart=/usr/bin/vector --config /etc/vector/vector.toml
OVERRIDE_EOF

    # Reload systemd daemon to pick up changes
    progress "Reloading systemd daemon..."
    systemctl daemon-reload >> "${ACTVT_LOG_FILE}" 2>&1

    # Enable systemd service
    progress "Enabling Vector service..."
    systemctl enable vector >> "${ACTVT_LOG_FILE}" 2>&1

    # Start service
    progress "Starting Vector with custom configuration..."
    if systemctl start vector >> "${ACTVT_LOG_FILE}" 2>&1; then
        progress "Vector service start command issued"
    else
        log ERROR "Failed to start Vector service"
        log INFO "Checking service status..."
        systemctl status vector --no-pager >> "${ACTVT_LOG_FILE}" 2>&1 || true
        error_exit "Vector service failed to start. Check logs: journalctl -u vector -n 50"
    fi

    # Wait for service to become active (poll up to 30 seconds)
    progress "Waiting for Vector service to become active..."
    local wait_count=0
    while ! systemctl is-active --quiet vector && [ $wait_count -lt 30 ]; do
        sleep 1
        wait_count=$((wait_count + 1))
    done

    # Verify service is running
    if ! systemctl is-active --quiet vector; then
        log ERROR "Vector service did not start within 30 seconds"
        systemctl status vector --no-pager >> "${ACTVT_LOG_FILE}" 2>&1 || true
        error_exit "Vector service is not running"
    fi

    progress "Vector service is active"

    # Give service a moment to fully initialize before checking logs
    sleep 2

    # Verify it's not running demo configuration
    if journalctl -u vector -n 20 --no-pager 2>/dev/null | grep -q "BronzeGamer\|meln1ks\|We're gonna need a bigger boat"; then
        log WARNING "Vector appears to be running with demo configuration, attempting restart..."
        systemctl restart vector >> "${ACTVT_LOG_FILE}" 2>&1 || true

        # Wait for restart to complete (poll up to 30 seconds)
        wait_count=0
        while ! systemctl is-active --quiet vector && [ $wait_count -lt 30 ]; do
            sleep 1
            wait_count=$((wait_count + 1))
        done

        if ! systemctl is-active --quiet vector; then
            error_exit "Vector service failed to restart"
        fi

        progress "Vector service restarted successfully"
    fi

    log SUCCESS "Vector service started and enabled"
}

###############################################################################
#                          Validation & Testing                               #
###############################################################################

validate_installation() {
    log STEP "Validating Installation"

    # Check Vector is running
    progress "Checking Vector service..."
    if systemctl is-active --quiet vector; then
        progress "Vector service: Running ✓"
    else
        log ERROR "Vector service is not running"
        return 1
    fi

    # Check port 4096 is listening
    progress "Checking WebSocket port..."
    if netstat -tuln 2>/dev/null | grep -q ":4096 " || \
       ss -tuln 2>/dev/null | grep -q ":4096 "; then
        progress "Port 4096: Listening ✓"
    else
        log WARNING "Port 4096 is not listening yet (may take a moment)"
    fi

    # Check TLS certificates exist and are valid
    progress "Checking TLS certificates..."
    if [ -f "${VECTOR_CERTS_DIR}/server.crt" ] && [ -f "${VECTOR_CERTS_DIR}/server.key" ]; then
        local cert_expiry=$(openssl x509 -in "${VECTOR_CERTS_DIR}/server.crt" -noout -enddate 2>/dev/null | cut -d= -f2)
        progress "TLS certificates: Valid until ${cert_expiry} ✓"
    else
        log ERROR "TLS certificates not found"
        return 1
    fi

    # Check mTLS certificates if enabled
    if [[ "${ACTVT_ENABLE_MTLS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        progress "Checking mTLS certificates..."
        if [ -f "${VECTOR_MTLS_DIR}/ca.crt" ] && [ -f "${VECTOR_MTLS_DIR}/ca.key" ]; then
            local ca_expiry=$(openssl x509 -in "${VECTOR_MTLS_DIR}/ca.crt" -noout -enddate 2>/dev/null | cut -d= -f2)
            progress "mTLS CA certificate: Valid until ${ca_expiry} ✓"

            # Check client certificate
            local client_cn="${ACTVT_MTLS_CLIENT_CN}"
            if [ -f "${VECTOR_MTLS_CLIENTS_DIR}/${client_cn}.crt" ]; then
                local client_expiry=$(openssl x509 -in "${VECTOR_MTLS_CLIENTS_DIR}/${client_cn}.crt" -noout -enddate 2>/dev/null | cut -d= -f2)
                progress "Client certificate: Valid until ${client_expiry} ✓"
            else
                log WARNING "Client certificate not found"
            fi
        else
            log ERROR "mTLS CA certificates not found"
            return 1
        fi
    else
        progress "mTLS: Disabled ⚠"
    fi

    # Get domain from state file
    local domain=""
    if [ -f "${ACTVT_STATE_DIR}/domain" ]; then
        domain=$(cat "${ACTVT_STATE_DIR}/domain")
    fi

    log SUCCESS "Installation validation complete"

    # Display connection information
    echo
    echo -e "${GREEN}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}${BOLD}  Installation Complete!${NC}"
    echo -e "${GREEN}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
    echo -e "${BOLD}Installation Mode:${NC} ${SELECTED_MODE}"
    echo
    echo -e "${BOLD}WebSocket URL:${NC}"
    if [ -n "${domain}" ]; then
        if [ "$SELECTED_MODE" = "proxy" ]; then
            echo -e "  ${CYAN}wss://${domain}/actvt${NC}"
            echo -e "  ${BOLD}(via nginx reverse proxy)${NC}"
        else
            echo -e "  ${CYAN}wss://${domain}:${ACTVT_VECTOR_PORT}${NC}"
            echo -e "  ${BOLD}(direct connection)${NC}"
        fi
    else
        if [ "$SELECTED_MODE" = "proxy" ]; then
            echo -e "  ${CYAN}wss://YOUR_DOMAIN/actvt${NC}"
        else
            echo -e "  ${CYAN}wss://YOUR_DOMAIN:${ACTVT_VECTOR_PORT}${NC}"
        fi
    fi
    echo
    # mTLS information
    if [[ "${ACTVT_ENABLE_MTLS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        local client_cn="${ACTVT_MTLS_CLIENT_CN}"
        echo -e "${BOLD}mTLS Client Certificates:${NC}"
        echo -e "  Client certificate bundle has been created at:"
        echo -e "  ${CYAN}${VECTOR_MTLS_DIR}/${client_cn}-bundle.tar.gz${NC}"
        echo -e ""
        echo -e "  Download this bundle to your local machine:"
        echo -e "  ${CYAN}scp root@${domain:-YOUR_SERVER}:${VECTOR_MTLS_DIR}/${client_cn}-bundle.tar.gz ./${NC}"
        echo -e ""
        echo -e "  Extract the bundle to get the required certificates:"
        echo -e "  ${CYAN}tar -xzf ${client_cn}-bundle.tar.gz${NC}"
        echo -e ""
        echo -e "  Files included:"
        echo -e "    • ${CYAN}ca.crt${NC} - CA certificate (for verification)"
        echo -e "    • ${CYAN}clients/${client_cn}.crt${NC} - Client certificate"
        echo -e "    • ${CYAN}clients/${client_cn}.key${NC} - Client private key"
        echo
    else
        echo -e "${BOLD}Security Warning:${NC}"
        echo -e "  ${YELLOW}⚠ mTLS is DISABLED${NC}"
        echo -e "  Any client can connect without authentication"
        echo -e "  Consider enabling mTLS for production use"
        echo
    fi
    echo -e "${BOLD}Next Steps:${NC}"
    echo -e "  1. Download the client certificate bundle (see above)"
    echo -e "  2. Open Actvt on your Mac"
    echo -e "  3. Go to Settings → Remote Servers"
    echo -e "  4. Add a new server with the WebSocket URL and certificates"
    echo -e "  5. Start monitoring your remote server!"
    echo
    echo -e "${BOLD}Service Management:${NC}"
    echo -e "  • Check status:  ${CYAN}sudo systemctl status vector${NC}"
    echo -e "  • View logs:     ${CYAN}sudo journalctl -u vector -f${NC}"
    echo -e "  • Restart:       ${CYAN}sudo systemctl restart vector${NC}"
    echo
    if [[ "${ACTVT_ENABLE_MTLS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        echo -e "${BOLD}mTLS Certificate Management:${NC}"
        echo -e "  • Generate new client cert:"
        echo -e "    ${CYAN}sudo ${VECTOR_MTLS_DIR}/generate-client.sh actvt-client-002${NC}"
        echo -e "  • List certificates:"
        echo -e "    ${CYAN}ls -la ${VECTOR_MTLS_CLIENTS_DIR}/${NC}"
        echo -e "  • Check certificate expiry:"
        echo -e "    ${CYAN}openssl x509 -in ${VECTOR_MTLS_CLIENTS_DIR}/${ACTVT_MTLS_CLIENT_CN}.crt -noout -dates${NC}"
        echo
    fi
    echo -e "${BOLD}Documentation:${NC}"
    echo -e "  ${CYAN}https://actvt.io/docs/remote-server/overview${NC}"
    echo
    echo -e "${GREEN}${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
}

###############################################################################
#                              Main Execution                                 #
###############################################################################

main() {
    # Clear screen and show banner
    clear
    echo -e "${CYAN}${BOLD}"
    echo "╔═══════════════════════════════════════════════════════════════╗"
    echo "║                                                               ║"
    echo "║           Actvt Remote Server Installation Script            ║"
    echo "║                      Version ${SCRIPT_VERSION}                        ║"
    echo "║                                                               ║"
    echo "╚═══════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    echo

    # Validate and create state directories
    # Validate state directory path to prevent path traversal
    if [[ ! "${ACTVT_STATE_DIR}" =~ ^/var/lib/actvt$ ]]; then
        echo "ERROR: Invalid state directory path: ${ACTVT_STATE_DIR}" >&2
        exit 1
    fi

    # Validate backup directory path to prevent path traversal
    if [[ ! "${ACTVT_BACKUP_DIR}" =~ ^/var/lib/actvt/backups$ ]]; then
        echo "ERROR: Invalid backup directory path: ${ACTVT_BACKUP_DIR}" >&2
        exit 1
    fi

    # Create directories with restrictive permissions
    mkdir -p "${ACTVT_STATE_DIR}"
    chmod 700 "${ACTVT_STATE_DIR}"
    mkdir -p "${ACTVT_BACKUP_DIR}"
    chmod 700 "${ACTVT_BACKUP_DIR}"

    # Initialize log file
    touch "${ACTVT_LOG_FILE}" 2>/dev/null || ACTVT_LOG_FILE="/tmp/actvt-install.log"
    chmod 600 "${ACTVT_LOG_FILE}"

    log INFO "Starting Actvt installation (version ${SCRIPT_VERSION})"
    log INFO "Log file: ${ACTVT_LOG_FILE}"

    # Run installation steps
    detect_os
    check_requirements
    detect_existing_webserver
    determine_installation_mode
    install_vector
    setup_tls
    setup_mtls
    configure_vector
    configure_nginx_proxy
    configure_firewall
    start_vector_service
    validate_installation

    # Save installation state
    echo "version=${SCRIPT_VERSION}" > "${ACTVT_STATE_DIR}/install.state"
    echo "installed_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "${ACTVT_STATE_DIR}/install.state"
    echo "mode=${SELECTED_MODE}" >> "${ACTVT_STATE_DIR}/install.state"
    echo "webserver=${EXISTING_WEBSERVER:-none}" >> "${ACTVT_STATE_DIR}/install.state"
    if [[ "${ACTVT_ENABLE_MTLS}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        echo "mtls=enabled" >> "${ACTVT_STATE_DIR}/install.state"
        echo "mtls_client_cn=${ACTVT_MTLS_CLIENT_CN}" >> "${ACTVT_STATE_DIR}/install.state"
    else
        echo "mtls=disabled" >> "${ACTVT_STATE_DIR}/install.state"
    fi

    log INFO "Installation completed successfully"
}

# Run main function
main "$@"
